{
  "version": 3,
  "sources": ["../node_modules/source-map-js/lib/base64.js", "../node_modules/source-map-js/lib/base64-vlq.js", "../node_modules/source-map-js/lib/util.js", "../node_modules/source-map-js/lib/array-set.js", "../node_modules/source-map-js/lib/mapping-list.js", "../node_modules/source-map-js/lib/source-map-generator.js", "../src/index.js", "../node_modules/css-tree/lib/tokenizer/char-code-definitions.js", "../node_modules/css-tree/lib/tokenizer/utils.js", "../node_modules/css-tree/lib/tokenizer/names.js", "../node_modules/css-tree/lib/tokenizer/adopt-buffer.js", "../node_modules/css-tree/lib/tokenizer/OffsetToLocation.js", "../node_modules/css-tree/lib/tokenizer/TokenStream.js", "../node_modules/css-tree/lib/tokenizer/index.js", "../node_modules/css-tree/lib/generator/sourceMap.js", "../node_modules/css-tree/lib/generator/token-before.js", "../node_modules/css-tree/lib/generator/create.js", "../node_modules/css-tree/lib/syntax/node/index-generate.js", "../node_modules/css-tree/lib/syntax/node/AnPlusB.js", "../node_modules/css-tree/lib/syntax/node/Atrule.js", "../node_modules/css-tree/lib/syntax/node/AtrulePrelude.js", "../node_modules/css-tree/lib/syntax/node/AttributeSelector.js", "../node_modules/css-tree/lib/syntax/node/Block.js", "../node_modules/css-tree/lib/syntax/node/Brackets.js", "../node_modules/css-tree/lib/syntax/node/CDC.js", "../node_modules/css-tree/lib/syntax/node/CDO.js", "../node_modules/css-tree/lib/syntax/node/ClassSelector.js", "../node_modules/css-tree/lib/syntax/node/Combinator.js", "../node_modules/css-tree/lib/syntax/node/Comment.js", "../node_modules/css-tree/lib/syntax/node/Condition.js", "../node_modules/css-tree/lib/syntax/node/Declaration.js", "../node_modules/css-tree/lib/syntax/node/DeclarationList.js", "../node_modules/css-tree/lib/syntax/node/Dimension.js", "../node_modules/css-tree/lib/syntax/node/Feature.js", "../node_modules/css-tree/lib/syntax/node/FeatureFunction.js", "../node_modules/css-tree/lib/syntax/node/FeatureRange.js", "../node_modules/css-tree/lib/syntax/node/Function.js", "../node_modules/css-tree/lib/syntax/node/GeneralEnclosed.js", "../node_modules/css-tree/lib/syntax/node/Hash.js", "../node_modules/css-tree/lib/syntax/node/Identifier.js", "../node_modules/css-tree/lib/syntax/node/IdSelector.js", "../node_modules/css-tree/lib/syntax/node/Layer.js", "../node_modules/css-tree/lib/syntax/node/LayerList.js", "../node_modules/css-tree/lib/syntax/node/MediaQuery.js", "../node_modules/css-tree/lib/syntax/node/MediaQueryList.js", "../node_modules/css-tree/lib/syntax/node/NestingSelector.js", "../node_modules/css-tree/lib/syntax/node/Nth.js", "../node_modules/css-tree/lib/syntax/node/Number.js", "../node_modules/css-tree/lib/syntax/node/Operator.js", "../node_modules/css-tree/lib/syntax/node/Parentheses.js", "../node_modules/css-tree/lib/syntax/node/Percentage.js", "../node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js", "../node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js", "../node_modules/css-tree/lib/syntax/node/Ratio.js", "../node_modules/css-tree/lib/syntax/node/Raw.js", "../node_modules/css-tree/lib/syntax/node/Rule.js", "../node_modules/css-tree/lib/syntax/node/Scope.js", "../node_modules/css-tree/lib/syntax/node/Selector.js", "../node_modules/css-tree/lib/syntax/node/SelectorList.js", "../node_modules/css-tree/lib/utils/string.js", "../node_modules/css-tree/lib/syntax/node/String.js", "../node_modules/css-tree/lib/syntax/node/StyleSheet.js", "../node_modules/css-tree/lib/syntax/node/SupportsDeclaration.js", "../node_modules/css-tree/lib/syntax/node/TypeSelector.js", "../node_modules/css-tree/lib/syntax/node/UnicodeRange.js", "../node_modules/css-tree/lib/utils/url.js", "../node_modules/css-tree/lib/syntax/node/Url.js", "../node_modules/css-tree/lib/syntax/node/Value.js", "../node_modules/css-tree/lib/syntax/node/WhiteSpace.js", "../node_modules/css-tree/lib/syntax/config/generator.js", "../node_modules/css-tree/lib/generator/index.js", "../node_modules/css-tree/lib/utils/List.js", "../node_modules/css-tree/lib/utils/create-custom-error.js", "../node_modules/css-tree/lib/parser/SyntaxError.js", "../node_modules/css-tree/lib/parser/sequence.js", "../node_modules/css-tree/lib/parser/create.js", "../node_modules/css-tree/lib/syntax/scope/selector.js", "../node_modules/css-tree/lib/syntax/pseudo/lang.js", "../node_modules/css-tree/lib/syntax/pseudo/index.js", "../node_modules/css-tree/lib/syntax/node/index-parse-selector.js", "../node_modules/css-tree/lib/syntax/config/parser-selector.js", "../node_modules/css-tree/lib/parser/parse-selector.js", "../src/util/compare.js", "../src/util/sort.js", "../src/util/filter.js", "../src/core/calculate.js"],
  "sourcesContent": ["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n\n/**\n * Decode a single base 64 character code digit to an integer. Returns -1 on\n * failure.\n */\nexports.decode = function (charCode) {\n  var bigA = 65;     // 'A'\n  var bigZ = 90;     // 'Z'\n\n  var littleA = 97;  // 'a'\n  var littleZ = 122; // 'z'\n\n  var zero = 48;     // '0'\n  var nine = 57;     // '9'\n\n  var plus = 43;     // '+'\n  var slash = 47;    // '/'\n\n  var littleOffset = 26;\n  var numberOffset = 52;\n\n  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ\n  if (bigA <= charCode && charCode <= bigZ) {\n    return (charCode - bigA);\n  }\n\n  // 26 - 51: abcdefghijklmnopqrstuvwxyz\n  if (littleA <= charCode && charCode <= littleZ) {\n    return (charCode - littleA + littleOffset);\n  }\n\n  // 52 - 61: 0123456789\n  if (zero <= charCode && charCode <= nine) {\n    return (charCode - zero + numberOffset);\n  }\n\n  // 62: +\n  if (charCode == plus) {\n    return 62;\n  }\n\n  // 63: /\n  if (charCode == slash) {\n    return 63;\n  }\n\n  // Invalid base64 digit.\n  return -1;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar base64 = require('./base64');\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nvar VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nvar VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nvar VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nvar VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0\n    ? ((-aValue) << 1) + 1\n    : (aValue << 1) + 0;\n}\n\n/**\n * Converts to a two-complement value from a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1\n *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2\n */\nfunction fromVLQSigned(aValue) {\n  var isNegative = (aValue & 1) === 1;\n  var shifted = aValue >> 1;\n  return isNegative\n    ? -shifted\n    : shifted;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  var encoded = \"\";\n  var digit;\n\n  var vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n\n/**\n * Decodes the next base 64 VLQ value from the given string and returns the\n * value and the rest of the string via the out parameter.\n */\nexports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {\n  var strLen = aStr.length;\n  var result = 0;\n  var shift = 0;\n  var continuation, digit;\n\n  do {\n    if (aIndex >= strLen) {\n      throw new Error(\"Expected more digits in base 64 VLQ value.\");\n    }\n\n    digit = base64.decode(aStr.charCodeAt(aIndex++));\n    if (digit === -1) {\n      throw new Error(\"Invalid base64 digit: \" + aStr.charAt(aIndex - 1));\n    }\n\n    continuation = !!(digit & VLQ_CONTINUATION_BIT);\n    digit &= VLQ_BASE_MASK;\n    result = result + (digit << shift);\n    shift += VLQ_BASE_SHIFT;\n  } while (continuation);\n\n  aOutParam.value = fromVLQSigned(result);\n  aOutParam.rest = aIndex;\n};\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  } else {\n    throw new Error('\"' + aName + '\" is a required argument.');\n  }\n}\nexports.getArg = getArg;\n\nvar urlRegexp = /^(?:([\\w+\\-.]+):)?\\/\\/(?:(\\w+:\\w+)@)?([\\w.-]*)(?::(\\d+))?(.*)$/;\nvar dataUrlRegexp = /^data:.+\\,.+$/;\n\nfunction urlParse(aUrl) {\n  var match = aUrl.match(urlRegexp);\n  if (!match) {\n    return null;\n  }\n  return {\n    scheme: match[1],\n    auth: match[2],\n    host: match[3],\n    port: match[4],\n    path: match[5]\n  };\n}\nexports.urlParse = urlParse;\n\nfunction urlGenerate(aParsedUrl) {\n  var url = '';\n  if (aParsedUrl.scheme) {\n    url += aParsedUrl.scheme + ':';\n  }\n  url += '//';\n  if (aParsedUrl.auth) {\n    url += aParsedUrl.auth + '@';\n  }\n  if (aParsedUrl.host) {\n    url += aParsedUrl.host;\n  }\n  if (aParsedUrl.port) {\n    url += \":\" + aParsedUrl.port\n  }\n  if (aParsedUrl.path) {\n    url += aParsedUrl.path;\n  }\n  return url;\n}\nexports.urlGenerate = urlGenerate;\n\nvar MAX_CACHED_INPUTS = 32;\n\n/**\n * Takes some function `f(input) -> result` and returns a memoized version of\n * `f`.\n *\n * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The\n * memoization is a dumb-simple, linear least-recently-used cache.\n */\nfunction lruMemoize(f) {\n  var cache = [];\n\n  return function(input) {\n    for (var i = 0; i < cache.length; i++) {\n      if (cache[i].input === input) {\n        var temp = cache[0];\n        cache[0] = cache[i];\n        cache[i] = temp;\n        return cache[0].result;\n      }\n    }\n\n    var result = f(input);\n\n    cache.unshift({\n      input,\n      result,\n    });\n\n    if (cache.length > MAX_CACHED_INPUTS) {\n      cache.pop();\n    }\n\n    return result;\n  };\n}\n\n/**\n * Normalizes a path, or the path portion of a URL:\n *\n * - Replaces consecutive slashes with one slash.\n * - Removes unnecessary '.' parts.\n * - Removes unnecessary '<dir>/..' parts.\n *\n * Based on code in the Node.js 'path' core module.\n *\n * @param aPath The path or url to normalize.\n */\nvar normalize = lruMemoize(function normalize(aPath) {\n  var path = aPath;\n  var url = urlParse(aPath);\n  if (url) {\n    if (!url.path) {\n      return aPath;\n    }\n    path = url.path;\n  }\n  var isAbsolute = exports.isAbsolute(path);\n  // Split the path into parts between `/` characters. This is much faster than\n  // using `.split(/\\/+/g)`.\n  var parts = [];\n  var start = 0;\n  var i = 0;\n  while (true) {\n    start = i;\n    i = path.indexOf(\"/\", start);\n    if (i === -1) {\n      parts.push(path.slice(start));\n      break;\n    } else {\n      parts.push(path.slice(start, i));\n      while (i < path.length && path[i] === \"/\") {\n        i++;\n      }\n    }\n  }\n\n  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {\n    part = parts[i];\n    if (part === '.') {\n      parts.splice(i, 1);\n    } else if (part === '..') {\n      up++;\n    } else if (up > 0) {\n      if (part === '') {\n        // The first part is blank if the path is absolute. Trying to go\n        // above the root is a no-op. Therefore we can remove all '..' parts\n        // directly after the root.\n        parts.splice(i + 1, up);\n        up = 0;\n      } else {\n        parts.splice(i, 2);\n        up--;\n      }\n    }\n  }\n  path = parts.join('/');\n\n  if (path === '') {\n    path = isAbsolute ? '/' : '.';\n  }\n\n  if (url) {\n    url.path = path;\n    return urlGenerate(url);\n  }\n  return path;\n});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be joined with the root.\n *\n * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a\n *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended\n *   first.\n * - Otherwise aPath is a path. If aRoot is a URL, then its path portion\n *   is updated with the result and aRoot is returned. Otherwise the result\n *   is returned.\n *   - If aPath is absolute, the result is aPath.\n *   - Otherwise the two paths are joined with a slash.\n * - Joining for example 'http://' and 'www.example.com' is also supported.\n */\nfunction join(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n  if (aPath === \"\") {\n    aPath = \".\";\n  }\n  var aPathUrl = urlParse(aPath);\n  var aRootUrl = urlParse(aRoot);\n  if (aRootUrl) {\n    aRoot = aRootUrl.path || '/';\n  }\n\n  // `join(foo, '//www.example.org')`\n  if (aPathUrl && !aPathUrl.scheme) {\n    if (aRootUrl) {\n      aPathUrl.scheme = aRootUrl.scheme;\n    }\n    return urlGenerate(aPathUrl);\n  }\n\n  if (aPathUrl || aPath.match(dataUrlRegexp)) {\n    return aPath;\n  }\n\n  // `join('http://', 'www.example.com')`\n  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {\n    aRootUrl.host = aPath;\n    return urlGenerate(aRootUrl);\n  }\n\n  var joined = aPath.charAt(0) === '/'\n    ? aPath\n    : normalize(aRoot.replace(/\\/+$/, '') + '/' + aPath);\n\n  if (aRootUrl) {\n    aRootUrl.path = joined;\n    return urlGenerate(aRootUrl);\n  }\n  return joined;\n}\nexports.join = join;\n\nexports.isAbsolute = function (aPath) {\n  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);\n};\n\n/**\n * Make a path relative to a URL or another path.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n */\nfunction relative(aRoot, aPath) {\n  if (aRoot === \"\") {\n    aRoot = \".\";\n  }\n\n  aRoot = aRoot.replace(/\\/$/, '');\n\n  // It is possible for the path to be above the root. In this case, simply\n  // checking whether the root is a prefix of the path won't work. Instead, we\n  // need to remove components from the root one by one, until either we find\n  // a prefix that fits, or we run out of components to remove.\n  var level = 0;\n  while (aPath.indexOf(aRoot + '/') !== 0) {\n    var index = aRoot.lastIndexOf(\"/\");\n    if (index < 0) {\n      return aPath;\n    }\n\n    // If the only part of the root that is left is the scheme (i.e. http://,\n    // file:///, etc.), one or more slashes (/), or simply nothing at all, we\n    // have exhausted all components, so the path is not relative to the root.\n    aRoot = aRoot.slice(0, index);\n    if (aRoot.match(/^([^\\/]+:\\/)?\\/*$/)) {\n      return aPath;\n    }\n\n    ++level;\n  }\n\n  // Make sure we add a \"../\" for each component we removed from the root.\n  return Array(level + 1).join(\"../\") + aPath.substr(aRoot.length + 1);\n}\nexports.relative = relative;\n\nvar supportsNullProto = (function () {\n  var obj = Object.create(null);\n  return !('__proto__' in obj);\n}());\n\nfunction identity (s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return '$' + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  var length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 2) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n      s.charCodeAt(length - 8) !== 95  /* '_' */ ||\n      s.charCodeAt(length - 9) !== 95  /* '_' */) {\n    return false;\n  }\n\n  for (var i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Comparator between two mappings where the original positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same original source/line/column, but different generated\n * line and column the same. Useful when searching for a mapping with a\n * stubbed out mapping.\n */\nfunction compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositions = compareByOriginalPositions;\n\nfunction compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {\n  var cmp\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0 || onlyCompareOriginal) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;\n\n/**\n * Comparator between two mappings with deflated source and name indices where\n * the generated positions are compared.\n *\n * Optionally pass in `true` as `onlyCompareGenerated` to consider two\n * mappings with the same generated line and column, but different\n * source/name/original line and column the same. Useful when searching for a\n * mapping with a stubbed out mapping.\n */\nfunction compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;\n\nfunction compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {\n  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0 || onlyCompareGenerated) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  var cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, ''));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  sourceURL = sourceURL || '';\n\n  if (sourceRoot) {\n    // This follows what Chrome does.\n    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {\n      sourceRoot += '/';\n    }\n    // The spec says:\n    //   Line 4: An optional source root, useful for relocating source\n    //   files on a server or removing repeated values in the\n    //   \u201Csources\u201D entry.  This value is prepended to the individual\n    //   entries in the \u201Csource\u201D field.\n    sourceURL = sourceRoot + sourceURL;\n  }\n\n  // Historically, SourceMapConsumer did not take the sourceMapURL as\n  // a parameter.  This mode is still somewhat supported, which is why\n  // this code block is conditional.  However, it's preferable to pass\n  // the source map URL to SourceMapConsumer, so that this function\n  // can implement the source URL resolution algorithm as outlined in\n  // the spec.  This block is basically the equivalent of:\n  //    new URL(sourceURL, sourceMapURL).toString()\n  // ... except it avoids using URL, which wasn't available in the\n  // older releases of node still supported by this library.\n  //\n  // The spec says:\n  //   If the sources are not absolute URLs after prepending of the\n  //   \u201CsourceRoot\u201D, the sources are resolved relative to the\n  //   SourceMap (like resolving script src in a html document).\n  if (sourceMapURL) {\n    var parsed = urlParse(sourceMapURL);\n    if (!parsed) {\n      throw new Error(\"sourceMapURL could not be parsed\");\n    }\n    if (parsed.path) {\n      // Strip the last path component, but keep the \"/\".\n      var index = parsed.path.lastIndexOf('/');\n      if (index >= 0) {\n        parsed.path = parsed.path.substring(0, index + 1);\n      }\n    }\n    sourceURL = join(urlGenerate(parsed), sourceURL);\n  }\n\n  return normalize(sourceURL);\n}\nexports.computeSourceURL = computeSourceURL;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\nvar has = Object.prototype.hasOwnProperty;\nvar hasNativeMap = typeof Map !== \"undefined\";\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nfunction ArraySet() {\n  this._array = [];\n  this._set = hasNativeMap ? new Map() : Object.create(null);\n}\n\n/**\n * Static method for creating ArraySet instances from an existing array.\n */\nArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {\n  var set = new ArraySet();\n  for (var i = 0, len = aArray.length; i < len; i++) {\n    set.add(aArray[i], aAllowDuplicates);\n  }\n  return set;\n};\n\n/**\n * Return how many unique items are in this ArraySet. If duplicates have been\n * added, than those do not count towards the size.\n *\n * @returns Number\n */\nArraySet.prototype.size = function ArraySet_size() {\n  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;\n};\n\n/**\n * Add the given string to this set.\n *\n * @param String aStr\n */\nArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {\n  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);\n  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);\n  var idx = this._array.length;\n  if (!isDuplicate || aAllowDuplicates) {\n    this._array.push(aStr);\n  }\n  if (!isDuplicate) {\n    if (hasNativeMap) {\n      this._set.set(aStr, idx);\n    } else {\n      this._set[sStr] = idx;\n    }\n  }\n};\n\n/**\n * Is the given string a member of this set?\n *\n * @param String aStr\n */\nArraySet.prototype.has = function ArraySet_has(aStr) {\n  if (hasNativeMap) {\n    return this._set.has(aStr);\n  } else {\n    var sStr = util.toSetString(aStr);\n    return has.call(this._set, sStr);\n  }\n};\n\n/**\n * What is the index of the given string in the array?\n *\n * @param String aStr\n */\nArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {\n  if (hasNativeMap) {\n    var idx = this._set.get(aStr);\n    if (idx >= 0) {\n        return idx;\n    }\n  } else {\n    var sStr = util.toSetString(aStr);\n    if (has.call(this._set, sStr)) {\n      return this._set[sStr];\n    }\n  }\n\n  throw new Error('\"' + aStr + '\" is not in the set.');\n};\n\n/**\n * What is the element at the given index?\n *\n * @param Number aIdx\n */\nArraySet.prototype.at = function ArraySet_at(aIdx) {\n  if (aIdx >= 0 && aIdx < this._array.length) {\n    return this._array[aIdx];\n  }\n  throw new Error('No element indexed by ' + aIdx);\n};\n\n/**\n * Returns the array representation of this set (which has the proper indices\n * indicated by indexOf). Note that this is a copy of the internal array used\n * for storing the members so that no one can mess with internal state.\n */\nArraySet.prototype.toArray = function ArraySet_toArray() {\n  return this._array.slice();\n};\n\nexports.ArraySet = ArraySet;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar util = require('./util');\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  var lineA = mappingA.generatedLine;\n  var lineB = mappingB.generatedLine;\n  var columnA = mappingA.generatedColumn;\n  var columnB = mappingB.generatedColumn;\n  return lineB > lineA || lineB == lineA && columnB >= columnA ||\n         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a neglibable overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nfunction MappingList() {\n  this._array = [];\n  this._sorted = true;\n  // Serves as infimum\n  this._last = {generatedLine: -1, generatedColumn: 0};\n}\n\n/**\n * Iterate through internal items. This method takes the same arguments that\n * `Array.prototype.forEach` takes.\n *\n * NOTE: The order of the mappings is NOT guaranteed.\n */\nMappingList.prototype.unsortedForEach =\n  function MappingList_forEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  };\n\n/**\n * Add the given source mapping.\n *\n * @param Object aMapping\n */\nMappingList.prototype.add = function MappingList_add(aMapping) {\n  if (generatedPositionAfter(this._last, aMapping)) {\n    this._last = aMapping;\n    this._array.push(aMapping);\n  } else {\n    this._sorted = false;\n    this._array.push(aMapping);\n  }\n};\n\n/**\n * Returns the flat, sorted array of mappings. The mappings are sorted by\n * generated position.\n *\n * WARNING: This method returns internal data without copying, for\n * performance. The return value must NOT be mutated, and should be treated as\n * an immutable borrow. If you want to take ownership, you must make your own\n * copy.\n */\nMappingList.prototype.toArray = function MappingList_toArray() {\n  if (!this._sorted) {\n    this._array.sort(util.compareByGeneratedPositionsInflated);\n    this._sorted = true;\n  }\n  return this._array;\n};\n\nexports.MappingList = MappingList;\n", "/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nvar base64VLQ = require('./base64-vlq');\nvar util = require('./util');\nvar ArraySet = require('./array-set').ArraySet;\nvar MappingList = require('./mapping-list').MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nfunction SourceMapGenerator(aArgs) {\n  if (!aArgs) {\n    aArgs = {};\n  }\n  this._file = util.getArg(aArgs, 'file', null);\n  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);\n  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);\n  this._sources = new ArraySet();\n  this._names = new ArraySet();\n  this._mappings = new MappingList();\n  this._sourcesContents = null;\n}\n\nSourceMapGenerator.prototype._version = 3;\n\n/**\n * Creates a new SourceMapGenerator based on a SourceMapConsumer\n *\n * @param aSourceMapConsumer The SourceMap.\n */\nSourceMapGenerator.fromSourceMap =\n  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {\n    var sourceRoot = aSourceMapConsumer.sourceRoot;\n    var generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot: sourceRoot\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      var newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn\n        }\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var sourceRelative = sourceFile;\n      if (sourceRoot !== null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  };\n\n/**\n * Add a single mapping from original source line and column to the generated\n * source's line and column for this source map being created. The mapping\n * object should have the following properties:\n *\n *   - generated: An object with the generated line and column positions.\n *   - original: An object with the original line and column positions.\n *   - source: The original source file (relative to the sourceRoot).\n *   - name: An optional original token name for this mapping.\n */\nSourceMapGenerator.prototype.addMapping =\n  function SourceMapGenerator_addMapping(aArgs) {\n    var generated = util.getArg(aArgs, 'generated');\n    var original = util.getArg(aArgs, 'original', null);\n    var source = util.getArg(aArgs, 'source', null);\n    var name = util.getArg(aArgs, 'name', null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original != null && original.line,\n      originalColumn: original != null && original.column,\n      source: source,\n      name: name\n    });\n  };\n\n/**\n * Set the source content for a source file.\n */\nSourceMapGenerator.prototype.setSourceContent =\n  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {\n    var source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  };\n\n/**\n * Applies the mappings of a sub-source-map for a specific source file to the\n * source map being generated. Each mapping to the supplied source file is\n * rewritten using the supplied source map. Note: The resolution for the\n * resulting mappings is the minimium of this map and the supplied map.\n *\n * @param aSourceMapConsumer The source map to be applied.\n * @param aSourceFile Optional. The filename of the source file.\n *        If omitted, SourceMapConsumer's file property will be used.\n * @param aSourceMapPath Optional. The dirname of the path to the source map\n *        to be applied. If relative, it is relative to the SourceMapConsumer.\n *        This parameter is needed when the two source maps aren't in the same\n *        directory, and the source map to be applied contains relative source\n *        paths. If so, those relative source paths need to be rewritten\n *        relative to the SourceMapGenerator.\n */\nSourceMapGenerator.prototype.applySourceMap =\n  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    var sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +\n          'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    var sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    var newSources = new ArraySet();\n    var newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        var original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source)\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      var source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      var name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          sourceFile = util.join(aSourceMapPath, sourceFile);\n        }\n        if (sourceRoot != null) {\n          sourceFile = util.relative(sourceRoot, sourceFile);\n        }\n        this.setSourceContent(sourceFile, content);\n      }\n    }, this);\n  };\n\n/**\n * A mapping can have one of the three levels of data:\n *\n *   1. Just the generated position.\n *   2. The Generated position, original position, and original source.\n *   3. Generated and original position, original source, as well as a name\n *      token.\n *\n * To maintain consistency, we validate that any new mapping being added falls\n * in to one of these categories.\n */\nSourceMapGenerator.prototype._validateMapping =\n  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,\n                                              aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {\n        throw new Error(\n            'original.line and original.column are not numbers -- you probably meant to omit ' +\n            'the original mapping entirely and only map the generated position. If so, pass ' +\n            'null for the original mapping instead of an object with empty or null values.'\n        );\n    }\n\n    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n        && aGenerated.line > 0 && aGenerated.column >= 0\n        && !aOriginal && !aSource && !aName) {\n      // Case 1.\n      return;\n    }\n    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated\n             && aOriginal && 'line' in aOriginal && 'column' in aOriginal\n             && aGenerated.line > 0 && aGenerated.column >= 0\n             && aOriginal.line > 0 && aOriginal.column >= 0\n             && aSource) {\n      // Cases 2 and 3.\n      return;\n    }\n    else {\n      throw new Error('Invalid mapping: ' + JSON.stringify({\n        generated: aGenerated,\n        source: aSource,\n        original: aOriginal,\n        name: aName\n      }));\n    }\n  };\n\n/**\n * Serialize the accumulated mappings in to the stream of base 64 VLQs\n * specified by the source map format.\n */\nSourceMapGenerator.prototype._serializeMappings =\n  function SourceMapGenerator_serializeMappings() {\n    var previousGeneratedColumn = 0;\n    var previousGeneratedLine = 1;\n    var previousOriginalColumn = 0;\n    var previousOriginalLine = 0;\n    var previousName = 0;\n    var previousSource = 0;\n    var result = '';\n    var next;\n    var mapping;\n    var nameIdx;\n    var sourceIdx;\n\n    var mappings = this._mappings.toArray();\n    for (var i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = ''\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += ';';\n          previousGeneratedLine++;\n        }\n      }\n      else {\n        if (i > 0) {\n          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {\n            continue;\n          }\n          next += ',';\n        }\n      }\n\n      next += base64VLQ.encode(mapping.generatedColumn\n                                 - previousGeneratedColumn);\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(mapping.originalLine - 1\n                                   - previousOriginalLine);\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(mapping.originalColumn\n                                   - previousOriginalColumn);\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  };\n\nSourceMapGenerator.prototype._generateSourcesContent =\n  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      var key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  };\n\n/**\n * Externalize the source map.\n */\nSourceMapGenerator.prototype.toJSON =\n  function SourceMapGenerator_toJSON() {\n    var map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings()\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);\n    }\n\n    return map;\n  };\n\n/**\n * Render the source map being generated to a string.\n */\nSourceMapGenerator.prototype.toString =\n  function SourceMapGenerator_toString() {\n    return JSON.stringify(this.toJSON());\n  };\n\nexports.SourceMapGenerator = SourceMapGenerator;\n", "import generate from 'css-tree/generator';\n\nimport { calculate, calculateForAST } from './core/index.js';\nimport { compare, equals, greaterThan, lessThan } from './util/compare.js';\nimport { min, max } from './util/filter.js';\nimport { sortAsc, sortDesc } from './util/sort.js';\n\nclass NotAllowedError extends Error {\n    constructor() {\n        super('Manipulating a Specificity instance is not allowed. Instead, create a new Specificity()');\n    }\n}\n\nclass Specificity {\n    constructor(value, selector = null) {\n        this.value = value;\n        this.selector = selector;\n    }\n\n    get a() {\n        return this.value.a;\n    }\n\n    set a(val) {\n        throw new NotAllowedError();\n    }\n\n    get b() {\n        return this.value.b;\n    }\n\n    set b(val) {\n        throw new NotAllowedError();\n    }\n\n    get c() {\n        return this.value.c;\n    }\n\n    set c(val) {\n        throw new NotAllowedError();\n    }\n\n    selectorString() {\n        // this.selector already is a String\n        if (typeof this.selector === 'string' || this.selector instanceof String) {\n            return this.selector;\n        }\n\n        // this.selector is a Selector as parsed by CSSTree\n        if (this.selector instanceof Object) {\n            if (this.selector.type === 'Selector') {\n                return generate(this.selector);\n            }\n        }\n\n        // this.selector is something else \u2026\n        return '';\n    }\n\n    toObject() {\n        return this.value;\n    }\n\n    toArray() {\n        return [this.value.a, this.value.b, this.value.c];\n    }\n\n    toString() {\n        return `(${this.value.a},${this.value.b},${this.value.c})`;\n    }\n\n    toJSON() {\n        return {\n            selector: this.selectorString(),\n            asObject: this.toObject(),\n            asArray: this.toArray(),\n            asString: this.toString(),\n        };\n    }\n\n    isEqualTo(otherSpecificity) {\n        return equals(this, otherSpecificity);\n    }\n\n    isGreaterThan(otherSpecificity) {\n        return greaterThan(this, otherSpecificity);\n    }\n\n    isLessThan(otherSpecificity) {\n        return lessThan(this, otherSpecificity);\n    }\n\n    static calculate(selector) {\n        return calculate(selector);\n    }\n\n    static calculateForAST(selector) {\n        return calculateForAST(selector);\n    }\n\n    static compare(s1, s2) {\n        return compare(s1, s2);\n    }\n\n    static equals(s1, s2) {\n        return equals(s1, s2);\n    }\n\n    static lessThan(s1, s2) {\n        return lessThan(s1, s2);\n    }\n\n    static greaterThan(s1, s2) {\n        return greaterThan(s1, s2);\n    }\n\n    static min(...specificities) {\n        return min(...specificities);\n    }\n\n    static max(...specificities) {\n        return max(...specificities);\n    }\n\n    static sortAsc(...specificities) {\n        return sortAsc(...specificities);\n    }\n\n    static sortDesc(...specificities) {\n        return sortDesc(...specificities);\n    }\n}\n\nexport default Specificity;\n", "const EOF = 0;\n\n// https://drafts.csswg.org/css-syntax-3/\n// \u00A7 4.2. Definitions\n\n// digit\n// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).\nexport function isDigit(code) {\n    return code >= 0x0030 && code <= 0x0039;\n}\n\n// hex digit\n// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),\n// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).\nexport function isHexDigit(code) {\n    return (\n        isDigit(code) || // 0 .. 9\n        (code >= 0x0041 && code <= 0x0046) || // A .. F\n        (code >= 0x0061 && code <= 0x0066)    // a .. f\n    );\n}\n\n// uppercase letter\n// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).\nexport function isUppercaseLetter(code) {\n    return code >= 0x0041 && code <= 0x005A;\n}\n\n// lowercase letter\n// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).\nexport function isLowercaseLetter(code) {\n    return code >= 0x0061 && code <= 0x007A;\n}\n\n// letter\n// An uppercase letter or a lowercase letter.\nexport function isLetter(code) {\n    return isUppercaseLetter(code) || isLowercaseLetter(code);\n}\n\n// non-ASCII code point\n// A code point with a value equal to or greater than U+0080 <control>.\n//\n// 2024-09-02: The latest spec narrows the range for non-ASCII characters (see https://github.com/csstree/csstree/issues/188).\n// However, all modern browsers support a wider range, and strictly following the latest spec could result\n// in some CSS being parsed incorrectly, even though it works in the browser. Therefore, this function adheres\n// to the previous, broader definition of non-ASCII characters.\nexport function isNonAscii(code) {\n    return code >= 0x0080;\n}\n\n// name-start code point\n// A letter, a non-ASCII code point, or U+005F LOW LINE (_).\nexport function isNameStart(code) {\n    return isLetter(code) || isNonAscii(code) || code === 0x005F;\n}\n\n// name code point\n// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).\nexport function isName(code) {\n    return isNameStart(code) || isDigit(code) || code === 0x002D;\n}\n\n// non-printable code point\n// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,\n// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.\nexport function isNonPrintable(code) {\n    return (\n        (code >= 0x0000 && code <= 0x0008) ||\n        (code === 0x000B) ||\n        (code >= 0x000E && code <= 0x001F) ||\n        (code === 0x007F)\n    );\n}\n\n// newline\n// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,\n// as they are converted to U+000A LINE FEED during preprocessing.\n// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED\nexport function isNewline(code) {\n    return code === 0x000A || code === 0x000D || code === 0x000C;\n}\n\n// whitespace\n// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.\nexport function isWhiteSpace(code) {\n    return isNewline(code) || code === 0x0020 || code === 0x0009;\n}\n\n// \u00A7 4.3.8. Check if two code points are a valid escape\nexport function isValidEscape(first, second) {\n    // If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n    if (first !== 0x005C) {\n        return false;\n    }\n\n    // Otherwise, if the second code point is a newline or EOF, return false.\n    if (isNewline(second) || second === EOF) {\n        return false;\n    }\n\n    // Otherwise, return true.\n    return true;\n}\n\n// \u00A7 4.3.9. Check if three code points would start an identifier\nexport function isIdentifierStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002D HYPHEN-MINUS\n    if (first === 0x002D) {\n        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,\n        // or the second and third code points are a valid escape, return true. Otherwise, return false.\n        return (\n            isNameStart(second) ||\n            second === 0x002D ||\n            isValidEscape(second, third)\n        );\n    }\n\n    // name-start code point\n    if (isNameStart(first)) {\n        // Return true.\n        return true;\n    }\n\n    // U+005C REVERSE SOLIDUS (\\)\n    if (first === 0x005C) {\n        // If the first and second code points are a valid escape, return true. Otherwise, return false.\n        return isValidEscape(first, second);\n    }\n\n    // anything else\n    // Return false.\n    return false;\n}\n\n// \u00A7 4.3.10. Check if three code points would start a number\nexport function isNumberStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002B PLUS SIGN (+)\n    // U+002D HYPHEN-MINUS (-)\n    if (first === 0x002B || first === 0x002D) {\n        // If the second code point is a digit, return true.\n        if (isDigit(second)) {\n            return 2;\n        }\n\n        // Otherwise, if the second code point is a U+002E FULL STOP (.)\n        // and the third code point is a digit, return true.\n        // Otherwise, return false.\n        return second === 0x002E && isDigit(third) ? 3 : 0;\n    }\n\n    // U+002E FULL STOP (.)\n    if (first === 0x002E) {\n        // If the second code point is a digit, return true. Otherwise, return false.\n        return isDigit(second) ? 2 : 0;\n    }\n\n    // digit\n    if (isDigit(first)) {\n        // Return true.\n        return 1;\n    }\n\n    // anything else\n    // Return false.\n    return 0;\n}\n\n//\n// Misc\n//\n\n// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)\nexport function isBOM(code) {\n    // UTF-16BE\n    if (code === 0xFEFF) {\n        return 1;\n    }\n\n    // UTF-16LE\n    if (code === 0xFFFE) {\n        return 1;\n    }\n\n    return 0;\n}\n\n// Fast code category\n// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only\nconst CATEGORY = new Array(0x80);\nexport const EofCategory = 0x80;\nexport const WhiteSpaceCategory = 0x82;\nexport const DigitCategory = 0x83;\nexport const NameStartCategory = 0x84;\nexport const NonPrintableCategory = 0x85;\n\nfor (let i = 0; i < CATEGORY.length; i++) {\n    CATEGORY[i] =\n        isWhiteSpace(i) && WhiteSpaceCategory ||\n        isDigit(i) && DigitCategory ||\n        isNameStart(i) && NameStartCategory ||\n        isNonPrintable(i) && NonPrintableCategory ||\n        i || EofCategory;\n}\n\nexport function charCodeCategory(code) {\n    return code < 0x80 ? CATEGORY[code] : NameStartCategory;\n}\n", "import {\n    isDigit,\n    isHexDigit,\n    isUppercaseLetter,\n    isName,\n    isWhiteSpace,\n    isValidEscape\n} from './char-code-definitions.js';\n\nfunction getCharCode(source, offset) {\n    return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nexport function getNewlineLength(source, offset, code) {\n    if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n        return 2;\n    }\n\n    return 1;\n}\n\nexport function cmpChar(testStr, offset, referenceCode) {\n    let code = testStr.charCodeAt(offset);\n\n    // code.toLowerCase() for A..Z\n    if (isUppercaseLetter(code)) {\n        code = code | 32;\n    }\n\n    return code === referenceCode;\n}\n\nexport function cmpStr(testStr, start, end, referenceStr) {\n    if (end - start !== referenceStr.length) {\n        return false;\n    }\n\n    if (start < 0 || end > testStr.length) {\n        return false;\n    }\n\n    for (let i = start; i < end; i++) {\n        const referenceCode = referenceStr.charCodeAt(i - start);\n        let testCode = testStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for A..Z\n        if (isUppercaseLetter(testCode)) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nexport function findWhiteSpaceStart(source, offset) {\n    for (; offset >= 0; offset--) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset + 1;\n}\n\nexport function findWhiteSpaceEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nexport function findDecimalNumberEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isDigit(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\n// \u00A7 4.3.7. Consume an escaped code point\nexport function consumeEscaped(source, offset) {\n    // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n    // that the next input code point has already been verified to be part of a valid escape.\n    offset += 2;\n\n    // hex digit\n    if (isHexDigit(getCharCode(source, offset - 1))) {\n        // Consume as many hex digits as possible, but no more than 5.\n        // Note that this means 1-6 hex digits have been consumed in total.\n        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n            if (!isHexDigit(getCharCode(source, offset))) {\n                break;\n            }\n        }\n\n        // If the next input code point is whitespace, consume it as well.\n        const code = getCharCode(source, offset);\n        if (isWhiteSpace(code)) {\n            offset += getNewlineLength(source, offset, code);\n        }\n    }\n\n    return offset;\n}\n\n// \u00A74.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nexport function consumeName(source, offset) {\n    // Let result initially be an empty string.\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // name code point\n        if (isName(code)) {\n            // Append the code point to result.\n            continue;\n        }\n\n        // the stream starts with a valid escape\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point. Append the returned code point to result.\n            offset = consumeEscaped(source, offset) - 1;\n            continue;\n        }\n\n        // anything else\n        // Reconsume the current input code point. Return result.\n        break;\n    }\n\n    return offset;\n}\n\n// \u00A74.3.12. Consume a number\nexport function consumeNumber(source, offset) {\n    let code = source.charCodeAt(offset);\n\n    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (code === 0x002B || code === 0x002D) {\n        code = source.charCodeAt(offset += 1);\n    }\n\n    // 3. While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = source.charCodeAt(offset);\n    }\n\n    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n        // 4.1 Consume them.\n        // 4.2 Append them to repr.\n        offset += 2;\n\n        // 4.3 Set type to \"number\".\n        // TODO\n\n        // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n        offset = findDecimalNumberEnd(source, offset);\n    }\n\n    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (cmpChar(source, offset, 101 /* e */)) {\n        let sign = 0;\n        code = source.charCodeAt(offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (code === 0x002D || code === 0x002B) {\n            sign = 1;\n            code = source.charCodeAt(offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // 5.1 Consume them.\n            // 5.2 Append them to repr.\n\n            // 5.3 Set type to \"number\".\n            // TODO\n\n            // 5.4 While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\n// \u00A7 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nexport function consumeBadUrlRemnants(source, offset) {\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        const code = source.charCodeAt(offset);\n\n        // U+0029 RIGHT PARENTHESIS ())\n        // EOF\n        if (code === 0x0029) {\n            // Return.\n            offset++;\n            break;\n        }\n\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point.\n            // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n            // without ending the <bad-url-token>. This is otherwise identical to\n            // the \"anything else\" clause.\n            offset = consumeEscaped(source, offset);\n        }\n    }\n\n    return offset;\n}\n\n// \u00A7 4.3.7. Consume an escaped code point\n// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\\)\nexport function decodeEscaped(escaped) {\n    // Single char escaped that's not a hex digit\n    if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {\n        return escaped[0];\n    }\n\n    // Interpret the hex digits as a hexadecimal number.\n    let code = parseInt(escaped, 16);\n\n    if (\n        (code === 0) ||                       // If this number is zero,\n        (code >= 0xD800 && code <= 0xDFFF) || // or is for a surrogate,\n        (code > 0x10FFFF)                     // or is greater than the maximum allowed code point\n    ) {\n        // ... return U+FFFD REPLACEMENT CHARACTER\n        code = 0xFFFD;\n    }\n\n    // Otherwise, return the code point with that value.\n    return String.fromCodePoint(code);\n}\n", "export default [\n    'EOF-token',\n    'ident-token',\n    'function-token',\n    'at-keyword-token',\n    'hash-token',\n    'string-token',\n    'bad-string-token',\n    'url-token',\n    'bad-url-token',\n    'delim-token',\n    'number-token',\n    'percentage-token',\n    'dimension-token',\n    'whitespace-token',\n    'CDO-token',\n    'CDC-token',\n    'colon-token',\n    'semicolon-token',\n    'comma-token',\n    '[-token',\n    ']-token',\n    '(-token',\n    ')-token',\n    '{-token',\n    '}-token',\n    'comment-token'\n];\n", "const MIN_SIZE = 16 * 1024;\n\nexport function adoptBuffer(buffer = null, size) {\n    if (buffer === null || buffer.length < size) {\n        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));\n    }\n\n    return buffer;\n};\n", "import { adoptBuffer } from './adopt-buffer.js';\nimport { isBOM } from './char-code-definitions.js';\n\nconst N = 10;\nconst F = 12;\nconst R = 13;\n\nfunction computeLinesAndColumns(host) {\n    const source = host.source;\n    const sourceLength = source.length;\n    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;\n    const lines = adoptBuffer(host.lines, sourceLength);\n    const columns = adoptBuffer(host.columns, sourceLength);\n    let line = host.startLine;\n    let column = host.startColumn;\n\n    for (let i = startOffset; i < sourceLength; i++) {\n        const code = source.charCodeAt(i);\n\n        lines[i] = line;\n        columns[i] = column++;\n\n        if (code === N || code === R || code === F) {\n            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {\n                i++;\n                lines[i] = line;\n                columns[i] = column;\n            }\n\n            line++;\n            column = 1;\n        }\n    }\n\n    lines[sourceLength] = line;\n    columns[sourceLength] = column;\n\n    host.lines = lines;\n    host.columns = columns;\n    host.computed = true;\n}\n\nexport class OffsetToLocation {\n    constructor() {\n        this.lines = null;\n        this.columns = null;\n        this.computed = false;\n    }\n    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {\n        this.source = source;\n        this.startOffset = startOffset;\n        this.startLine = startLine;\n        this.startColumn = startColumn;\n        this.computed = false;\n    }\n    getLocation(offset, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            offset: this.startOffset + offset,\n            line: this.lines[offset],\n            column: this.columns[offset]\n        };\n    }\n    getLocationRange(start, end, filename) {\n        if (!this.computed) {\n            computeLinesAndColumns(this);\n        }\n\n        return {\n            source: filename,\n            start: {\n                offset: this.startOffset + start,\n                line: this.lines[start],\n                column: this.columns[start]\n            },\n            end: {\n                offset: this.startOffset + end,\n                line: this.lines[end],\n                column: this.columns[end]\n            }\n        };\n    }\n};\n", "import { adoptBuffer } from './adopt-buffer.js';\nimport { cmpStr } from './utils.js';\nimport tokenNames from './names.js';\nimport {\n    WhiteSpace,\n    Comment,\n    Delim,\n    EOF,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis,\n    LeftSquareBracket,\n    RightSquareBracket,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from './types.js';\n\nconst OFFSET_MASK = 0x00FFFFFF;\nconst TYPE_SHIFT = 24;\nconst balancePair = new Map([\n    [FunctionToken, RightParenthesis],\n    [LeftParenthesis, RightParenthesis],\n    [LeftSquareBracket, RightSquareBracket],\n    [LeftCurlyBracket, RightCurlyBracket]\n]);\n\nexport class TokenStream {\n    constructor(source, tokenize) {\n        this.setSource(source, tokenize);\n    }\n    reset() {\n        this.eof = false;\n        this.tokenIndex = -1;\n        this.tokenType = 0;\n        this.tokenStart = this.firstCharOffset;\n        this.tokenEnd = this.firstCharOffset;\n    }\n    setSource(source = '', tokenize = () => {}) {\n        source = String(source || '');\n\n        const sourceLength = source.length;\n        const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token\n        const balance = adoptBuffer(this.balance, source.length + 1);\n        let tokenCount = 0;\n        let balanceCloseType = 0;\n        let balanceStart = 0;\n        let firstCharOffset = -1;\n\n        // capture buffers\n        this.offsetAndType = null;\n        this.balance = null;\n\n        tokenize(source, (type, start, end) => {\n            switch (type) {\n                default:\n                    balance[tokenCount] = sourceLength;\n                    break;\n\n                case balanceCloseType: {\n                    let balancePrev = balanceStart & OFFSET_MASK;\n                    balanceStart = balance[balancePrev];\n                    balanceCloseType = balanceStart >> TYPE_SHIFT;\n                    balance[tokenCount] = balancePrev;\n                    balance[balancePrev++] = tokenCount;\n                    for (; balancePrev < tokenCount; balancePrev++) {\n                        if (balance[balancePrev] === sourceLength) {\n                            balance[balancePrev] = tokenCount;\n                        }\n                    }\n                    break;\n                }\n\n                case LeftParenthesis:\n                case FunctionToken:\n                case LeftSquareBracket:\n                case LeftCurlyBracket:\n                    balance[tokenCount] = balanceStart;\n                    balanceCloseType = balancePair.get(type);\n                    balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;\n                    break;\n            }\n\n            offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | end;\n            if (firstCharOffset === -1) {\n                firstCharOffset = start;\n            }\n        });\n\n        // finalize buffers\n        offsetAndType[tokenCount] = (EOF << TYPE_SHIFT) | sourceLength; // <EOF-token>\n        balance[tokenCount] = sourceLength;\n        balance[sourceLength] = sourceLength; // prevents false positive balance match with any token\n        while (balanceStart !== 0) {\n            const balancePrev = balanceStart & OFFSET_MASK;\n            balanceStart = balance[balancePrev];\n            balance[balancePrev] = sourceLength;\n        }\n\n        this.source = source;\n        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;\n        this.tokenCount = tokenCount;\n        this.offsetAndType = offsetAndType;\n        this.balance = balance;\n\n        this.reset();\n        this.next();\n    }\n\n    lookupType(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset] >> TYPE_SHIFT;\n        }\n\n        return EOF;\n    }\n    lookupTypeNonSC(idx) {\n        for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {\n            const tokenType = this.offsetAndType[offset] >> TYPE_SHIFT;\n\n            if (tokenType !== WhiteSpace && tokenType !== Comment) {\n                if (idx-- === 0) {\n                    return tokenType;\n                }\n            }\n        }\n\n        return EOF;\n    }\n    lookupOffset(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset - 1] & OFFSET_MASK;\n        }\n\n        return this.source.length;\n    }\n    lookupOffsetNonSC(idx) {\n        for (let offset = this.tokenIndex; offset < this.tokenCount; offset++) {\n            const tokenType = this.offsetAndType[offset] >> TYPE_SHIFT;\n\n            if (tokenType !== WhiteSpace && tokenType !== Comment) {\n                if (idx-- === 0) {\n                    return offset - this.tokenIndex;\n                }\n            }\n        }\n\n        return EOF;\n    }\n    lookupValue(offset, referenceStr) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return cmpStr(\n                this.source,\n                this.offsetAndType[offset - 1] & OFFSET_MASK,\n                this.offsetAndType[offset] & OFFSET_MASK,\n                referenceStr\n            );\n        }\n\n        return false;\n    }\n    getTokenStart(tokenIndex) {\n        if (tokenIndex === this.tokenIndex) {\n            return this.tokenStart;\n        }\n\n        if (tokenIndex > 0) {\n            return tokenIndex < this.tokenCount\n                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n        }\n\n        return this.firstCharOffset;\n    }\n    substrToCursor(start) {\n        return this.source.substring(start, this.tokenStart);\n    }\n\n    isBalanceEdge(pos) {\n        return this.balance[this.tokenIndex] < pos;\n    }\n    isDelim(code, offset) {\n        if (offset) {\n            return (\n                this.lookupType(offset) === Delim &&\n                this.source.charCodeAt(this.lookupOffset(offset)) === code\n            );\n        }\n\n        return (\n            this.tokenType === Delim &&\n            this.source.charCodeAt(this.tokenStart) === code\n        );\n    }\n\n    skip(tokenCount) {\n        let next = this.tokenIndex + tokenCount;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.next();\n        }\n    }\n    next() {\n        let next = this.tokenIndex + 1;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.tokenEnd;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.eof = true;\n            this.tokenIndex = this.tokenCount;\n            this.tokenType = EOF;\n            this.tokenStart = this.tokenEnd = this.source.length;\n        }\n    }\n    skipSC() {\n        while (this.tokenType === WhiteSpace || this.tokenType === Comment) {\n            this.next();\n        }\n    }\n    skipUntilBalanced(startToken, stopConsume) {\n        let cursor = startToken;\n        let balanceEnd;\n        let offset;\n\n        loop:\n        for (; cursor < this.tokenCount; cursor++) {\n            balanceEnd = this.balance[cursor];\n\n            // stop scanning on balance edge that points to offset before start token\n            if (balanceEnd < startToken) {\n                break loop;\n            }\n\n            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;\n\n            // check stop condition\n            switch (stopConsume(this.source.charCodeAt(offset))) {\n                case 1: // just stop\n                    break loop;\n\n                case 2: // stop & included\n                    cursor++;\n                    break loop;\n\n                default:\n                    // fast forward to the end of balanced block\n                    if (this.balance[balanceEnd] === cursor) {\n                        cursor = balanceEnd;\n                    }\n            }\n        }\n\n        this.skip(cursor - this.tokenIndex);\n    }\n\n    forEachToken(fn) {\n        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {\n            const start = offset;\n            const item = this.offsetAndType[i];\n            const end = item & OFFSET_MASK;\n            const type = item >> TYPE_SHIFT;\n\n            offset = end;\n\n            fn(type, start, end, i);\n        }\n    }\n    dump() {\n        const tokens = new Array(this.tokenCount);\n\n        this.forEachToken((type, start, end, index) => {\n            tokens[index] = {\n                idx: index,\n                type: tokenNames[type],\n                chunk: this.source.substring(start, end),\n                balance: this.balance[index]\n            };\n        });\n\n        return tokens;\n    }\n};\n", "import * as TYPE from './types.js';\nimport {\n    isNewline,\n    isName,\n    isValidEscape,\n    isNumberStart,\n    isIdentifierStart,\n    isBOM,\n    charCodeCategory,\n    WhiteSpaceCategory,\n    DigitCategory,\n    NameStartCategory,\n    NonPrintableCategory\n} from './char-code-definitions.js';\nimport {\n    cmpStr,\n    getNewlineLength,\n    findWhiteSpaceEnd,\n    consumeEscaped,\n    consumeName,\n    consumeNumber,\n    consumeBadUrlRemnants\n} from './utils.js';\n\nexport function tokenize(source, onToken) {\n    function getCharCode(offset) {\n        return offset < sourceLength ? source.charCodeAt(offset) : 0;\n    }\n\n    // \u00A7 4.3.3. Consume a numeric token\n    function consumeNumericToken() {\n        // Consume a number and let number be the result.\n        offset = consumeNumber(source, offset);\n\n        // If the next 3 input code points would start an identifier, then:\n        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {\n            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n            // Consume a name. Set the <dimension-token>\u2019s unit to the returned value.\n            // Return the <dimension-token>.\n            type = TYPE.Dimension;\n            offset = consumeName(source, offset);\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n        if (getCharCode(offset) === 0x0025) {\n            // Create a <percentage-token> with the same value as number, and return it.\n            type = TYPE.Percentage;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n        type = TYPE.Number;\n    }\n\n    // \u00A7 4.3.4. Consume an ident-like token\n    function consumeIdentLikeToken() {\n        const nameStartOffset = offset;\n\n        // Consume a name, and let string be the result.\n        offset = consumeName(source, offset);\n\n        // If string\u2019s value is an ASCII case-insensitive match for \"url\",\n        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {\n            // While the next two input code points are whitespace, consume the next input code point.\n            offset = findWhiteSpaceEnd(source, offset + 1);\n\n            // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),\n            // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('),\n            // then create a <function-token> with its value set to string and return it.\n            if (getCharCode(offset) === 0x0022 ||\n                getCharCode(offset) === 0x0027) {\n                type = TYPE.Function;\n                offset = nameStartOffset + 4;\n                return;\n            }\n\n            // Otherwise, consume a url token, and return it.\n            consumeUrlToken();\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        // Create a <function-token> with its value set to string and return it.\n        if (getCharCode(offset) === 0x0028) {\n            type = TYPE.Function;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create an <ident-token> with its value set to string and return it.\n        type = TYPE.Ident;\n    }\n\n    // \u00A7 4.3.5. Consume a string token\n    function consumeStringToken(endingCodePoint) {\n        // This algorithm may be called with an ending code point, which denotes the code point\n        // that ends the string. If an ending code point is not specified,\n        // the current input code point is used.\n        if (!endingCodePoint) {\n            endingCodePoint = getCharCode(offset++);\n        }\n\n        // Initially create a <string-token> with its value set to the empty string.\n        type = TYPE.String;\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // ending code point\n                case endingCodePoint:\n                    // Return the <string-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <string-token>.\n                    // return;\n\n                // newline\n                case WhiteSpaceCategory:\n                    if (isNewline(code)) {\n                        // This is a parse error. Reconsume the current input code point,\n                        // create a <bad-string-token>, and return it.\n                        offset += getNewlineLength(source, offset, code);\n                        type = TYPE.BadString;\n                        return;\n                    }\n                    break;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the next input code point is EOF, do nothing.\n                    if (offset === source.length - 1) {\n                        break;\n                    }\n\n                    const nextCode = getCharCode(offset + 1);\n\n                    // Otherwise, if the next input code point is a newline, consume it.\n                    if (isNewline(nextCode)) {\n                        offset += getNewlineLength(source, offset + 1, nextCode);\n                    } else if (isValidEscape(code, nextCode)) {\n                        // Otherwise, (the stream starts with a valid escape) consume\n                        // an escaped code point and append the returned code point to\n                        // the <string-token>\u2019s value.\n                        offset = consumeEscaped(source, offset) - 1;\n                    }\n                    break;\n\n                // anything else\n                // Append the current input code point to the <string-token>\u2019s value.\n            }\n        }\n    }\n\n    // \u00A7 4.3.6. Consume a url token\n    // Note: This algorithm assumes that the initial \"url(\" has already been consumed.\n    // This algorithm also assumes that it\u2019s being called to consume an \"unquoted\" value, like url(foo).\n    // A quoted value, like url(\"foo\"), is parsed as a <function-token>. Consume an ident-like token\n    // automatically handles this distinction; this algorithm shouldn\u2019t be called directly otherwise.\n    function consumeUrlToken() {\n        // Initially create a <url-token> with its value set to the empty string.\n        type = TYPE.Url;\n\n        // Consume as much whitespace as possible.\n        offset = findWhiteSpaceEnd(source, offset);\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            const code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // U+0029 RIGHT PARENTHESIS ())\n                case 0x0029:\n                    // Return the <url-token>.\n                    offset++;\n                    return;\n\n                    // EOF\n                    // case EofCategory:\n                    // This is a parse error. Return the <url-token>.\n                    // return;\n\n                // whitespace\n                case WhiteSpaceCategory:\n                    // Consume as much whitespace as possible.\n                    offset = findWhiteSpaceEnd(source, offset);\n\n                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,\n                    // consume it and return the <url-token>\n                    // (if EOF was encountered, this is a parse error);\n                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {\n                        if (offset < source.length) {\n                            offset++;\n                        }\n                        return;\n                    }\n\n                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,\n                    // and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+0022 QUOTATION MARK (\")\n                // U+0027 APOSTROPHE (')\n                // U+0028 LEFT PARENTHESIS (()\n                // non-printable code point\n                case 0x0022:\n                case 0x0027:\n                case 0x0028:\n                case NonPrintableCategory:\n                    // This is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the stream starts with a valid escape, consume an escaped code point and\n                    // append the returned code point to the <url-token>\u2019s value.\n                    if (isValidEscape(code, getCharCode(offset + 1))) {\n                        offset = consumeEscaped(source, offset) - 1;\n                        break;\n                    }\n\n                    // Otherwise, this is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // anything else\n                // Append the current input code point to the <url-token>\u2019s value.\n            }\n        }\n    }\n\n    // ensure source is a string\n    source = String(source || '');\n\n    const sourceLength = source.length;\n    let start = isBOM(getCharCode(0));\n    let offset = start;\n    let type;\n\n    // https://drafts.csswg.org/css-syntax-3/#consume-token\n    // \u00A7 4.3.1. Consume a token\n    while (offset < sourceLength) {\n        const code = source.charCodeAt(offset);\n\n        switch (charCodeCategory(code)) {\n            // whitespace\n            case WhiteSpaceCategory:\n                // Consume as much whitespace as possible. Return a <whitespace-token>.\n                type = TYPE.WhiteSpace;\n                offset = findWhiteSpaceEnd(source, offset + 1);\n                break;\n\n            // U+0022 QUOTATION MARK (\")\n            case 0x0022:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0023 NUMBER SIGN (#)\n            case 0x0023:\n                // If the next input code point is a name code point or the next two input code points are a valid escape, then:\n                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // Create a <hash-token>.\n                    type = TYPE.Hash;\n\n                    // If the next 3 input code points would start an identifier, set the <hash-token>\u2019s type flag to \"id\".\n                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    //     // TODO: set id flag\n                    // }\n\n                    // Consume a name, and set the <hash-token>\u2019s value to the returned string.\n                    offset = consumeName(source, offset + 1);\n\n                    // Return the <hash-token>.\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0027 APOSTROPHE (')\n            case 0x0027:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0028 LEFT PARENTHESIS (()\n            case 0x0028:\n                // Return a <(-token>.\n                type = TYPE.LeftParenthesis;\n                offset++;\n                break;\n\n            // U+0029 RIGHT PARENTHESIS ())\n            case 0x0029:\n                // Return a <)-token>.\n                type = TYPE.RightParenthesis;\n                offset++;\n                break;\n\n            // U+002B PLUS SIGN (+)\n            case 0x002B:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+002C COMMA (,)\n            case 0x002C:\n                // Return a <comma-token>.\n                type = TYPE.Comma;\n                offset++;\n                break;\n\n            // U+002D HYPHEN-MINUS (-)\n            case 0x002D:\n                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n                    if (getCharCode(offset + 1) === 0x002D &&\n                        getCharCode(offset + 2) === 0x003E) {\n                        type = TYPE.CDC;\n                        offset = offset + 3;\n                    } else {\n                        // Otherwise, if the input stream starts with an identifier, ...\n                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                            // ... reconsume the current input code point, consume an ident-like token, and return it.\n                            consumeIdentLikeToken();\n                        } else {\n                            // Otherwise, return a <delim-token> with its value set to the current input code point.\n                            type = TYPE.Delim;\n                            offset++;\n                        }\n                    }\n                }\n                break;\n\n            // U+002E FULL STOP (.)\n            case 0x002E:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+002F SOLIDUS (/)\n            case 0x002F:\n                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),\n                if (getCharCode(offset + 1) === 0x002A) {\n                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)\n                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.\n                    type = TYPE.Comment;\n                    offset = source.indexOf('*/', offset + 2);\n                    offset = offset === -1 ? source.length : offset + 2;\n                } else {\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+003A COLON (:)\n            case 0x003A:\n                // Return a <colon-token>.\n                type = TYPE.Colon;\n                offset++;\n                break;\n\n            // U+003B SEMICOLON (;)\n            case 0x003B:\n                // Return a <semicolon-token>.\n                type = TYPE.Semicolon;\n                offset++;\n                break;\n\n            // U+003C LESS-THAN SIGN (<)\n            case 0x003C:\n                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...\n                if (getCharCode(offset + 1) === 0x0021 &&\n                    getCharCode(offset + 2) === 0x002D &&\n                    getCharCode(offset + 3) === 0x002D) {\n                    // ... consume them and return a <CDO-token>.\n                    type = TYPE.CDO;\n                    offset = offset + 4;\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0040 COMMERCIAL AT (@)\n            case 0x0040:\n                // If the next 3 input code points would start an identifier, ...\n                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.\n                    type = TYPE.AtKeyword;\n                    offset = consumeName(source, offset + 1);\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+005B LEFT SQUARE BRACKET ([)\n            case 0x005B:\n                // Return a <[-token>.\n                type = TYPE.LeftSquareBracket;\n                offset++;\n                break;\n\n            // U+005C REVERSE SOLIDUS (\\)\n            case 0x005C:\n                // If the input stream starts with a valid escape, ...\n                if (isValidEscape(code, getCharCode(offset + 1))) {\n                    // ... reconsume the current input code point, consume an ident-like token, and return it.\n                    consumeIdentLikeToken();\n                } else {\n                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+005D RIGHT SQUARE BRACKET (])\n            case 0x005D:\n                // Return a <]-token>.\n                type = TYPE.RightSquareBracket;\n                offset++;\n                break;\n\n            // U+007B LEFT CURLY BRACKET ({)\n            case 0x007B:\n                // Return a <{-token>.\n                type = TYPE.LeftCurlyBracket;\n                offset++;\n                break;\n\n            // U+007D RIGHT CURLY BRACKET (})\n            case 0x007D:\n                // Return a <}-token>.\n                type = TYPE.RightCurlyBracket;\n                offset++;\n                break;\n\n            // digit\n            case DigitCategory:\n                // Reconsume the current input code point, consume a numeric token, and return it.\n                consumeNumericToken();\n                break;\n\n            // name-start code point\n            case NameStartCategory:\n                // Reconsume the current input code point, consume an ident-like token, and return it.\n                consumeIdentLikeToken();\n                break;\n\n                // EOF\n                // case EofCategory:\n                // Return an <EOF-token>.\n                // break;\n\n            // anything else\n            default:\n                // Return a <delim-token> with its value set to the current input code point.\n                type = TYPE.Delim;\n                offset++;\n        }\n\n        // put token to stream\n        onToken(type, start, start = offset);\n    }\n}\n\nexport * from './types.js';\nexport * as tokenTypes from './types.js';\nexport { default as tokenNames } from './names.js';\nexport * from './char-code-definitions.js';\nexport * from './utils.js';\nexport * from './OffsetToLocation.js';\nexport * from './TokenStream.js';\n", "import { SourceMapGenerator } from 'source-map-js/lib/source-map-generator.js';\n\nconst trackNodes = new Set(['Atrule', 'Selector', 'Declaration']);\n\nexport function generateSourceMap(handlers) {\n    const map = new SourceMapGenerator();\n    const generated = {\n        line: 1,\n        column: 0\n    };\n    const original = {\n        line: 0, // should be zero to add first mapping\n        column: 0\n    };\n    const activatedGenerated = {\n        line: 1,\n        column: 0\n    };\n    const activatedMapping = {\n        generated: activatedGenerated\n    };\n    let line = 1;\n    let column = 0;\n    let sourceMappingActive = false;\n\n    const origHandlersNode = handlers.node;\n    handlers.node = function(node) {\n        if (node.loc && node.loc.start && trackNodes.has(node.type)) {\n            const nodeLine = node.loc.start.line;\n            const nodeColumn = node.loc.start.column - 1;\n\n            if (original.line !== nodeLine ||\n                original.column !== nodeColumn) {\n                original.line = nodeLine;\n                original.column = nodeColumn;\n\n                generated.line = line;\n                generated.column = column;\n\n                if (sourceMappingActive) {\n                    sourceMappingActive = false;\n                    if (generated.line !== activatedGenerated.line ||\n                        generated.column !== activatedGenerated.column) {\n                        map.addMapping(activatedMapping);\n                    }\n                }\n\n                sourceMappingActive = true;\n                map.addMapping({\n                    source: node.loc.source,\n                    original,\n                    generated\n                });\n            }\n        }\n\n        origHandlersNode.call(this, node);\n\n        if (sourceMappingActive && trackNodes.has(node.type)) {\n            activatedGenerated.line = line;\n            activatedGenerated.column = column;\n        }\n    };\n\n    const origHandlersEmit = handlers.emit;\n    handlers.emit = function(value, type, auto) {\n        for (let i = 0; i < value.length; i++) {\n            if (value.charCodeAt(i) === 10) { // \\n\n                line++;\n                column = 0;\n            } else {\n                column++;\n            }\n        }\n\n        origHandlersEmit(value, type, auto);\n    };\n\n    const origHandlersResult = handlers.result;\n    handlers.result = function() {\n        if (sourceMappingActive) {\n            map.addMapping(activatedMapping);\n        }\n\n        return {\n            css: origHandlersResult(),\n            map\n        };\n    };\n\n    return handlers;\n};\n", "import {\n    WhiteSpace,\n    Delim,\n    Ident,\n    Function as FunctionToken,\n    Url,\n    BadUrl,\n    AtKeyword,\n    Hash,\n    Percentage,\n    Dimension,\n    Number as NumberToken,\n    String as StringToken,\n    Colon,\n    LeftParenthesis,\n    RightParenthesis,\n    CDC\n} from '../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\n\nconst code = (type, value) => {\n    if (type === Delim) {\n        type = value;\n    }\n\n    if (typeof type === 'string') {\n        const charCode = type.charCodeAt(0);\n        return charCode > 0x7F ? 0x8000 : charCode << 8;\n    }\n\n    return type;\n};\n\n// https://www.w3.org/TR/css-syntax-3/#serialization\n// The only requirement for serialization is that it must \"round-trip\" with parsing,\n// that is, parsing the stylesheet must produce the same data structures as parsing,\n// serializing, and parsing again, except for consecutive <whitespace-token>s,\n// which may be collapsed into a single token.\n\nconst specPairs = [\n    [Ident, Ident],\n    [Ident, FunctionToken],\n    [Ident, Url],\n    [Ident, BadUrl],\n    [Ident, '-'],\n    [Ident, NumberToken],\n    [Ident, Percentage],\n    [Ident, Dimension],\n    [Ident, CDC],\n    [Ident, LeftParenthesis],\n\n    [AtKeyword, Ident],\n    [AtKeyword, FunctionToken],\n    [AtKeyword, Url],\n    [AtKeyword, BadUrl],\n    [AtKeyword, '-'],\n    [AtKeyword, NumberToken],\n    [AtKeyword, Percentage],\n    [AtKeyword, Dimension],\n    [AtKeyword, CDC],\n\n    [Hash, Ident],\n    [Hash, FunctionToken],\n    [Hash, Url],\n    [Hash, BadUrl],\n    [Hash, '-'],\n    [Hash, NumberToken],\n    [Hash, Percentage],\n    [Hash, Dimension],\n    [Hash, CDC],\n\n    [Dimension, Ident],\n    [Dimension, FunctionToken],\n    [Dimension, Url],\n    [Dimension, BadUrl],\n    [Dimension, '-'],\n    [Dimension, NumberToken],\n    [Dimension, Percentage],\n    [Dimension, Dimension],\n    [Dimension, CDC],\n\n    ['#', Ident],\n    ['#', FunctionToken],\n    ['#', Url],\n    ['#', BadUrl],\n    ['#', '-'],\n    ['#', NumberToken],\n    ['#', Percentage],\n    ['#', Dimension],\n    ['#', CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['-', Ident],\n    ['-', FunctionToken],\n    ['-', Url],\n    ['-', BadUrl],\n    ['-', '-'],\n    ['-', NumberToken],\n    ['-', Percentage],\n    ['-', Dimension],\n    ['-', CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    [NumberToken, Ident],\n    [NumberToken, FunctionToken],\n    [NumberToken, Url],\n    [NumberToken, BadUrl],\n    [NumberToken, NumberToken],\n    [NumberToken, Percentage],\n    [NumberToken, Dimension],\n    [NumberToken, '%'],\n    [NumberToken, CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['@', Ident],\n    ['@', FunctionToken],\n    ['@', Url],\n    ['@', BadUrl],\n    ['@', '-'],\n    ['@', CDC], // https://github.com/w3c/csswg-drafts/pull/6874\n\n    ['.', NumberToken],\n    ['.', Percentage],\n    ['.', Dimension],\n\n    ['+', NumberToken],\n    ['+', Percentage],\n    ['+', Dimension],\n\n    ['/', '*']\n];\n// validate with scripts/generate-safe\nconst safePairs = specPairs.concat([\n    [Ident, Hash],\n\n    [Dimension, Hash],\n\n    [Hash, Hash],\n\n    [AtKeyword, LeftParenthesis],\n    [AtKeyword, StringToken],\n    [AtKeyword, Colon],\n\n    [Percentage, Percentage],\n    [Percentage, Dimension],\n    [Percentage, FunctionToken],\n    [Percentage, '-'],\n\n    [RightParenthesis, Ident],\n    [RightParenthesis, FunctionToken],\n    [RightParenthesis, Percentage],\n    [RightParenthesis, Dimension],\n    [RightParenthesis, Hash],\n    [RightParenthesis, '-']\n]);\n\nfunction createMap(pairs) {\n    const isWhiteSpaceRequired = new Set(\n        pairs.map(([prev, next]) => (code(prev) << 16 | code(next)))\n    );\n\n    return function(prevCode, type, value) {\n        const nextCode = code(type, value);\n        const nextCharCode = value.charCodeAt(0);\n        const emitWs =\n            (nextCharCode === HYPHENMINUS &&\n                type !== Ident &&\n                type !== FunctionToken &&\n                type !== CDC) ||\n            (nextCharCode === PLUSSIGN)\n                ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8)\n                : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);\n\n        if (emitWs) {\n            this.emit(' ', WhiteSpace, true);\n        }\n\n        return nextCode;\n    };\n}\n\nexport const spec = createMap(specPairs);\nexport const safe = createMap(safePairs);\n", "import { tokenize, Delim, WhiteSpace } from '../tokenizer/index.js';\nimport { generateSourceMap } from './sourceMap.js';\nimport * as tokenBefore from './token-before.js';\n\nconst REVERSESOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\n\nfunction processChildren(node, delimeter) {\n    if (typeof delimeter === 'function') {\n        let prev = null;\n\n        node.children.forEach(node => {\n            if (prev !== null) {\n                delimeter.call(this, prev);\n            }\n\n            this.node(node);\n            prev = node;\n        });\n\n        return;\n    }\n\n    node.children.forEach(this.node, this);\n}\n\nfunction processChunk(chunk) {\n    tokenize(chunk, (type, start, end) => {\n        this.token(type, chunk.slice(start, end));\n    });\n}\n\nexport function createGenerator(config) {\n    const types = new Map();\n\n    for (let [name, item] of Object.entries(config.node)) {\n        const fn = item.generate || item;\n\n        if (typeof fn === 'function') {\n            types.set(name, item.generate || item);\n        }\n    }\n\n    return function(node, options) {\n        let buffer = '';\n        let prevCode = 0;\n        let handlers = {\n            node(node) {\n                if (types.has(node.type)) {\n                    types.get(node.type).call(publicApi, node);\n                } else {\n                    throw new Error('Unknown node type: ' + node.type);\n                }\n            },\n            tokenBefore: tokenBefore.safe,\n            token(type, value) {\n                prevCode = this.tokenBefore(prevCode, type, value);\n\n                this.emit(value, type, false);\n\n                if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {\n                    this.emit('\\n', WhiteSpace, true);\n                }\n            },\n            emit(value) {\n                buffer += value;\n            },\n            result() {\n                return buffer;\n            }\n        };\n\n        if (options) {\n            if (typeof options.decorator === 'function') {\n                handlers = options.decorator(handlers);\n            }\n\n            if (options.sourceMap) {\n                handlers = generateSourceMap(handlers);\n            }\n\n            if (options.mode in tokenBefore) {\n                handlers.tokenBefore = tokenBefore[options.mode];\n            }\n        }\n\n        const publicApi = {\n            node: (node) => handlers.node(node),\n            children: processChildren,\n            token: (type, value) => handlers.token(type, value),\n            tokenize: processChunk\n        };\n\n        handlers.node(node);\n\n        return handlers.result();\n    };\n};\n", "export { generate as AnPlusB } from './AnPlusB.js';\nexport { generate as Atrule } from './Atrule.js';\nexport { generate as AtrulePrelude } from './AtrulePrelude.js';\nexport { generate as AttributeSelector } from './AttributeSelector.js';\nexport { generate as Block } from './Block.js';\nexport { generate as Brackets } from './Brackets.js';\nexport { generate as CDC } from './CDC.js';\nexport { generate as CDO } from './CDO.js';\nexport { generate as ClassSelector } from './ClassSelector.js';\nexport { generate as Combinator } from './Combinator.js';\nexport { generate as Comment } from './Comment.js';\nexport { generate as Condition } from './Condition.js';\nexport { generate as Declaration } from './Declaration.js';\nexport { generate as DeclarationList } from './DeclarationList.js';\nexport { generate as Dimension } from './Dimension.js';\nexport { generate as Feature } from './Feature.js';\nexport { generate as FeatureFunction } from './FeatureFunction.js';\nexport { generate as FeatureRange } from './FeatureRange.js';\nexport { generate as Function } from './Function.js';\nexport { generate as GeneralEnclosed } from './GeneralEnclosed.js';\nexport { generate as Hash } from './Hash.js';\nexport { generate as Identifier } from './Identifier.js';\nexport { generate as IdSelector } from './IdSelector.js';\nexport { generate as Layer } from './Layer.js';\nexport { generate as LayerList } from './LayerList.js';\nexport { generate as MediaQuery } from './MediaQuery.js';\nexport { generate as MediaQueryList } from './MediaQueryList.js';\nexport { generate as NestingSelector } from './NestingSelector.js';\nexport { generate as Nth } from './Nth.js';\nexport { generate as Number } from './Number.js';\nexport { generate as Operator } from './Operator.js';\nexport { generate as Parentheses } from './Parentheses.js';\nexport { generate as Percentage } from './Percentage.js';\nexport { generate as PseudoClassSelector } from './PseudoClassSelector.js';\nexport { generate as PseudoElementSelector } from './PseudoElementSelector.js';\nexport { generate as Ratio } from './Ratio.js';\nexport { generate as Raw } from './Raw.js';\nexport { generate as Rule } from './Rule.js';\nexport { generate as Scope } from './Scope.js';\nexport { generate as Selector } from './Selector.js';\nexport { generate as SelectorList } from './SelectorList.js';\nexport { generate as String } from './String.js';\nexport { generate as StyleSheet } from './StyleSheet.js';\nexport { generate as SupportsDeclaration } from './SupportsDeclaration.js';\nexport { generate as TypeSelector } from './TypeSelector.js';\nexport { generate as UnicodeRange } from './UnicodeRange.js';\nexport { generate as Url } from './Url.js';\nexport { generate as Value } from './Value.js';\nexport { generate as WhiteSpace } from './WhiteSpace.js';\n", "import {\n    isDigit,\n    WhiteSpace,\n    Comment,\n    Ident,\n    Number,\n    Dimension\n} from '../../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nconst N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\nconst DISALLOW_SIGN = true;\nconst ALLOW_SIGN = false;\n\nfunction checkInteger(offset, disallowSign) {\n    let pos = this.tokenStart + offset;\n    const code = this.charCodeAt(pos);\n\n    if (code === PLUSSIGN || code === HYPHENMINUS) {\n        if (disallowSign) {\n            this.error('Number sign is not allowed');\n        }\n        pos++;\n    }\n\n    for (; pos < this.tokenEnd; pos++) {\n        if (!isDigit(this.charCodeAt(pos))) {\n            this.error('Integer is expected', pos);\n        }\n    }\n}\n\nfunction checkTokenIsInteger(disallowSign) {\n    return checkInteger.call(this, 0, disallowSign);\n}\n\nfunction expectCharCode(offset, code) {\n    if (!this.cmpChar(this.tokenStart + offset, code)) {\n        let msg = '';\n\n        switch (code) {\n            case N:\n                msg = 'N is expected';\n                break;\n            case HYPHENMINUS:\n                msg = 'HyphenMinus is expected';\n                break;\n        }\n\n        this.error(msg, this.tokenStart + offset);\n    }\n}\n\n// ... <signed-integer>\n// ... ['+' | '-'] <signless-integer>\nfunction consumeB() {\n    let offset = 0;\n    let sign = 0;\n    let type = this.tokenType;\n\n    while (type === WhiteSpace || type === Comment) {\n        type = this.lookupType(++offset);\n    }\n\n    if (type !== Number) {\n        if (this.isDelim(PLUSSIGN, offset) ||\n            this.isDelim(HYPHENMINUS, offset)) {\n            sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;\n\n            do {\n                type = this.lookupType(++offset);\n            } while (type === WhiteSpace || type === Comment);\n\n            if (type !== Number) {\n                this.skip(offset);\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    if (offset > 0) {\n        this.skip(offset);\n    }\n\n    if (sign === 0) {\n        type = this.charCodeAt(this.tokenStart);\n        if (type !== PLUSSIGN && type !== HYPHENMINUS) {\n            this.error('Number sign is expected');\n        }\n    }\n\n    checkTokenIsInteger.call(this, sign !== 0);\n    return sign === HYPHENMINUS ? '-' + this.consume(Number) : this.consume(Number);\n}\n\n// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\nexport const name = 'AnPlusB';\nexport const structure = {\n    a: [String, null],\n    b: [String, null]\n};\n\nexport function parse() {\n    /* eslint-disable brace-style*/\n    const start = this.tokenStart;\n    let a = null;\n    let b = null;\n\n    // <integer>\n    if (this.tokenType === Number) {\n        checkTokenIsInteger.call(this, ALLOW_SIGN);\n        b = this.consume(Number);\n    }\n\n    // -n\n    // -n <signed-integer>\n    // -n ['+' | '-'] <signless-integer>\n    // -n- <signless-integer>\n    // <dashndashdigit-ident>\n    else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {\n        a = '-1';\n\n        expectCharCode.call(this, 1, N);\n\n        switch (this.tokenEnd - this.tokenStart) {\n            // -n\n            // -n <signed-integer>\n            // -n ['+' | '-'] <signless-integer>\n            case 2:\n                this.next();\n                b = consumeB.call(this);\n                break;\n\n            // -n- <signless-integer>\n            case 3:\n                expectCharCode.call(this, 2, HYPHENMINUS);\n\n                this.next();\n                this.skipSC();\n\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                b = '-' + this.consume(Number);\n                break;\n\n            // <dashndashdigit-ident>\n            default:\n                expectCharCode.call(this, 2, HYPHENMINUS);\n                checkInteger.call(this, 3, DISALLOW_SIGN);\n                this.next();\n\n                b = this.substrToCursor(start + 2);\n        }\n    }\n\n    // '+'? n\n    // '+'? n <signed-integer>\n    // '+'? n ['+' | '-'] <signless-integer>\n    // '+'? n- <signless-integer>\n    // '+'? <ndashdigit-ident>\n    else if (this.tokenType === Ident || (this.isDelim(PLUSSIGN) && this.lookupType(1) === Ident)) {\n        let sign = 0;\n        a = '1';\n\n        // just ignore a plus\n        if (this.isDelim(PLUSSIGN)) {\n            sign = 1;\n            this.next();\n        }\n\n        expectCharCode.call(this, 0, N);\n\n        switch (this.tokenEnd - this.tokenStart) {\n            // '+'? n\n            // '+'? n <signed-integer>\n            // '+'? n ['+' | '-'] <signless-integer>\n            case 1:\n                this.next();\n                b = consumeB.call(this);\n                break;\n\n            // '+'? n- <signless-integer>\n            case 2:\n                expectCharCode.call(this, 1, HYPHENMINUS);\n\n                this.next();\n                this.skipSC();\n\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                b = '-' + this.consume(Number);\n                break;\n\n            // '+'? <ndashdigit-ident>\n            default:\n                expectCharCode.call(this, 1, HYPHENMINUS);\n                checkInteger.call(this, 2, DISALLOW_SIGN);\n                this.next();\n\n                b = this.substrToCursor(start + sign + 1);\n        }\n    }\n\n    // <ndashdigit-dimension>\n    // <ndash-dimension> <signless-integer>\n    // <n-dimension>\n    // <n-dimension> <signed-integer>\n    // <n-dimension> ['+' | '-'] <signless-integer>\n    else if (this.tokenType === Dimension) {\n        const code = this.charCodeAt(this.tokenStart);\n        const sign = code === PLUSSIGN || code === HYPHENMINUS;\n        let i = this.tokenStart + sign;\n\n        for (; i < this.tokenEnd; i++) {\n            if (!isDigit(this.charCodeAt(i))) {\n                break;\n            }\n        }\n\n        if (i === this.tokenStart + sign) {\n            this.error('Integer is expected', this.tokenStart + sign);\n        }\n\n        expectCharCode.call(this, i - this.tokenStart, N);\n        a = this.substring(start, i);\n\n        // <n-dimension>\n        // <n-dimension> <signed-integer>\n        // <n-dimension> ['+' | '-'] <signless-integer>\n        if (i + 1 === this.tokenEnd) {\n            this.next();\n            b = consumeB.call(this);\n        } else {\n            expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);\n\n            // <ndash-dimension> <signless-integer>\n            if (i + 2 === this.tokenEnd) {\n                this.next();\n                this.skipSC();\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n                b = '-' + this.consume(Number);\n            }\n            // <ndashdigit-dimension>\n            else {\n                checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);\n                this.next();\n                b = this.substrToCursor(i + 1);\n            }\n        }\n    } else {\n        this.error();\n    }\n\n    if (a !== null && a.charCodeAt(0) === PLUSSIGN) {\n        a = a.substr(1);\n    }\n\n    if (b !== null && b.charCodeAt(0) === PLUSSIGN) {\n        b = b.substr(1);\n    }\n\n    return {\n        type: 'AnPlusB',\n        loc: this.getLocation(start, this.tokenStart),\n        a,\n        b\n    };\n}\n\nexport function generate(node) {\n    if (node.a) {\n        const a =\n            node.a === '+1' && 'n' ||\n            node.a ===  '1' && 'n' ||\n            node.a === '-1' && '-n' ||\n            node.a + 'n';\n\n        if (node.b) {\n            const b = node.b[0] === '-' || node.b[0] === '+'\n                ? node.b\n                : '+' + node.b;\n            this.tokenize(a + b);\n        } else {\n            this.tokenize(a);\n        }\n    } else {\n        this.tokenize(node.b);\n    }\n}\n", "import {\n    AtKeyword,\n    Semicolon,\n    LeftCurlyBracket,\n    RightCurlyBracket\n} from '../../tokenizer/index.js';\n\nfunction consumeRaw() {\n    return this.Raw(this.consumeUntilLeftCurlyBracketOrSemicolon, true);\n}\n\nfunction isDeclarationBlockAtrule() {\n    for (let offset = 1, type; type = this.lookupType(offset); offset++) {\n        if (type === RightCurlyBracket) {\n            return true;\n        }\n\n        if (type === LeftCurlyBracket ||\n            type === AtKeyword) {\n            return false;\n        }\n    }\n\n    return false;\n}\n\n\nexport const name = 'Atrule';\nexport const walkContext = 'atrule';\nexport const structure = {\n    name: String,\n    prelude: ['AtrulePrelude', 'Raw', null],\n    block: ['Block', null]\n};\n\nexport function parse(isDeclaration = false) {\n    const start = this.tokenStart;\n    let name;\n    let nameLowerCase;\n    let prelude = null;\n    let block = null;\n\n    this.eat(AtKeyword);\n\n    name = this.substrToCursor(start + 1);\n    nameLowerCase = name.toLowerCase();\n    this.skipSC();\n\n    // parse prelude\n    if (this.eof === false &&\n        this.tokenType !== LeftCurlyBracket &&\n        this.tokenType !== Semicolon) {\n        if (this.parseAtrulePrelude) {\n            prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name, isDeclaration), consumeRaw);\n        } else {\n            prelude = consumeRaw.call(this, this.tokenIndex);\n        }\n\n        this.skipSC();\n    }\n\n    switch (this.tokenType) {\n        case Semicolon:\n            this.next();\n            break;\n\n        case LeftCurlyBracket:\n            this.eat(LeftCurlyBracket);\n\n            if (hasOwnProperty.call(this.atrule, nameLowerCase) &&\n                typeof this.atrule[nameLowerCase].block === 'function') {\n                block = this.atrule[nameLowerCase].block.call(this, isDeclaration);\n            } else {\n                // TODO: should consume block content as Raw?\n                block = this.Block(isDeclarationBlockAtrule.call(this));\n            }\n\n            if (!this.eof) {\n                this.eat(RightCurlyBracket);\n            }\n\n            break;\n    }\n\n    return {\n        type: 'Atrule',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        prelude,\n        block\n    };\n}\n\nexport function generate(node) {\n    this.token(AtKeyword, '@' + node.name);\n\n    if (node.prelude !== null) {\n        this.node(node.prelude);\n    }\n\n    if (node.block) {\n        this.token(LeftCurlyBracket, '{');\n        this.node(node.block);\n        this.token(RightCurlyBracket, '}');\n    } else {\n        this.token(Semicolon, ';');\n    }\n}\n", "import {\n    Semicolon,\n    LeftCurlyBracket\n} from '../../tokenizer/index.js';\n\nexport const name = 'AtrulePrelude';\nexport const walkContext = 'atrulePrelude';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse(name) {\n    let children = null;\n\n    if (name !== null) {\n        name = name.toLowerCase();\n    }\n\n    this.skipSC();\n\n    if (hasOwnProperty.call(this.atrule, name) &&\n        typeof this.atrule[name].prelude === 'function') {\n        // custom consumer\n        children = this.atrule[name].prelude.call(this);\n    } else {\n        // default consumer\n        children = this.readSequence(this.scope.AtrulePrelude);\n    }\n\n    this.skipSC();\n\n    if (this.eof !== true &&\n        this.tokenType !== LeftCurlyBracket &&\n        this.tokenType !== Semicolon) {\n        this.error('Semicolon or block is expected');\n    }\n\n    return {\n        type: 'AtrulePrelude',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n", "import {\n    Ident,\n    String as StringToken,\n    Delim,\n    LeftSquareBracket,\n    RightSquareBracket\n} from '../../tokenizer/index.js';\n\nconst DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)\nconst ASTERISK = 0x002A;         // U+002A ASTERISK (*)\nconst EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)\nconst CIRCUMFLEXACCENT = 0x005E; // U+005E (^)\nconst VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)\nconst TILDE = 0x007E;            // U+007E TILDE (~)\n\nfunction getAttributeName() {\n    if (this.eof) {\n        this.error('Unexpected end of input');\n    }\n\n    const start = this.tokenStart;\n    let expectIdent = false;\n\n    if (this.isDelim(ASTERISK)) {\n        expectIdent = true;\n        this.next();\n    } else if (!this.isDelim(VERTICALLINE)) {\n        this.eat(Ident);\n    }\n\n    if (this.isDelim(VERTICALLINE)) {\n        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {\n            this.next();\n            this.eat(Ident);\n        } else if (expectIdent) {\n            this.error('Identifier is expected', this.tokenEnd);\n        }\n    } else if (expectIdent) {\n        this.error('Vertical line is expected');\n    }\n\n    return {\n        type: 'Identifier',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start)\n    };\n}\n\nfunction getOperator() {\n    const start = this.tokenStart;\n    const code = this.charCodeAt(start);\n\n    if (code !== EQUALSSIGN &&        // =\n        code !== TILDE &&             // ~=\n        code !== CIRCUMFLEXACCENT &&  // ^=\n        code !== DOLLARSIGN &&        // $=\n        code !== ASTERISK &&          // *=\n        code !== VERTICALLINE         // |=\n    ) {\n        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');\n    }\n\n    this.next();\n\n    if (code !== EQUALSSIGN) {\n        if (!this.isDelim(EQUALSSIGN)) {\n            this.error('Equal sign is expected');\n        }\n\n        this.next();\n    }\n\n    return this.substrToCursor(start);\n}\n\n// '[' <wq-name> ']'\n// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'\nexport const name = 'AttributeSelector';\nexport const structure = {\n    name: 'Identifier',\n    matcher: [String, null],\n    value: ['String', 'Identifier', null],\n    flags: [String, null]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    let name;\n    let matcher = null;\n    let value = null;\n    let flags = null;\n\n    this.eat(LeftSquareBracket);\n    this.skipSC();\n\n    name = getAttributeName.call(this);\n    this.skipSC();\n\n    if (this.tokenType !== RightSquareBracket) {\n        // avoid case `[name i]`\n        if (this.tokenType !== Ident) {\n            matcher = getOperator.call(this);\n\n            this.skipSC();\n\n            value = this.tokenType === StringToken\n                ? this.String()\n                : this.Identifier();\n\n            this.skipSC();\n        }\n\n        // attribute flags\n        if (this.tokenType === Ident) {\n            flags = this.consume(Ident);\n\n            this.skipSC();\n        }\n    }\n\n    this.eat(RightSquareBracket);\n\n    return {\n        type: 'AttributeSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        matcher,\n        value,\n        flags\n    };\n}\n\nexport function generate(node) {\n    this.token(Delim, '[');\n    this.node(node.name);\n\n    if (node.matcher !== null) {\n        this.tokenize(node.matcher);\n        this.node(node.value);\n    }\n\n    if (node.flags !== null) {\n        this.token(Ident, node.flags);\n    }\n\n    this.token(Delim, ']');\n}\n", "import {\n    WhiteSpace,\n    Comment,\n    Semicolon,\n    AtKeyword,\n    RightCurlyBracket\n} from '../../tokenizer/index.js';\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nfunction consumeRaw() {\n    return this.Raw(null, true);\n}\nfunction consumeRule() {\n    return this.parseWithFallback(this.Rule, consumeRaw);\n}\nfunction consumeRawDeclaration() {\n    return this.Raw(this.consumeUntilSemicolonIncluded, true);\n}\nfunction consumeDeclaration() {\n    if (this.tokenType === Semicolon) {\n        return consumeRawDeclaration.call(this, this.tokenIndex);\n    }\n\n    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);\n\n    if (this.tokenType === Semicolon) {\n        this.next();\n    }\n\n    return node;\n}\n\nexport const name = 'Block';\nexport const walkContext = 'block';\nexport const structure = {\n    children: [[\n        'Atrule',\n        'Rule',\n        'Declaration'\n    ]]\n};\n\nexport function parse(isStyleBlock) {\n    const consumer = isStyleBlock ? consumeDeclaration : consumeRule;\n    const start = this.tokenStart;\n    let children = this.createList();\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case RightCurlyBracket:\n                break scan;\n\n            case WhiteSpace:\n            case Comment:\n                this.next();\n                break;\n\n            case AtKeyword:\n                children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw));\n                break;\n\n            default:\n                if (isStyleBlock && this.isDelim(AMPERSAND))  {\n                    children.push(consumeRule.call(this));\n                } else {\n                    children.push(consumer.call(this));\n                }\n        }\n    }\n\n    return {\n        type: 'Block',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, prev => {\n        if (prev.type === 'Declaration') {\n            this.token(Semicolon, ';');\n        }\n    });\n}\n", "import {\n    Delim,\n    LeftSquareBracket,\n    RightSquareBracket\n} from '../../tokenizer/index.js';\n\nexport const name = 'Brackets';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    let children = null;\n\n    this.eat(LeftSquareBracket);\n\n    children = readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(RightSquareBracket);\n    }\n\n    return {\n        type: 'Brackets',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(Delim, '[');\n    this.children(node);\n    this.token(Delim, ']');\n}\n", "import { CDC } from '../../tokenizer/index.js';\n\nexport const name = 'CDC';\nexport const structure = [];\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(CDC); // -->\n\n    return {\n        type: 'CDC',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nexport function generate() {\n    this.token(CDC, '-->');\n}\n", "import { CDO } from '../../tokenizer/index.js';\n\nexport const name = 'CDO';\nexport const structure = [];\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(CDO); // <!--\n\n    return {\n        type: 'CDO',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nexport function generate() {\n    this.token(CDO, '<!--');\n}\n", "import { Delim, Ident } from '../../tokenizer/index.js';\n\nconst FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\n// '.' ident\nexport const name = 'ClassSelector';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    this.eatDelim(FULLSTOP);\n\n    return {\n        type: 'ClassSelector',\n        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),\n        name: this.consume(Ident)\n    };\n}\n\nexport function generate(node) {\n    this.token(Delim, '.');\n    this.token(Ident, node.name);\n}\n", "import { WhiteSpace, Delim } from '../../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nconst TILDE = 0x007E;           // U+007E TILDE (~)\n\nexport const name = 'Combinator';\nexport const structure = {\n    name: String\n};\n\n// + | > | ~ | /deep/\nexport function parse() {\n    const start = this.tokenStart;\n    let name;\n\n    switch (this.tokenType) {\n        case WhiteSpace:\n            name = ' ';\n            break;\n\n        case Delim:\n            switch (this.charCodeAt(this.tokenStart)) {\n                case GREATERTHANSIGN:\n                case PLUSSIGN:\n                case TILDE:\n                    this.next();\n                    break;\n\n                case SOLIDUS:\n                    this.next();\n                    this.eatIdent('deep');\n                    this.eatDelim(SOLIDUS);\n                    break;\n\n                default:\n                    this.error('Combinator is expected');\n            }\n\n            name = this.substrToCursor(start);\n            break;\n    }\n\n    return {\n        type: 'Combinator',\n        loc: this.getLocation(start, this.tokenStart),\n        name\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.name);\n}\n", "import { Comment } from '../../tokenizer/index.js';\n\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\n\nexport const name = 'Comment';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    let end = this.tokenEnd;\n\n    this.eat(Comment);\n\n    if ((end - start + 2) >= 2 &&\n        this.charCodeAt(end - 2) === ASTERISK &&\n        this.charCodeAt(end - 1) === SOLIDUS) {\n        end -= 2;\n    }\n\n    return {\n        type: 'Comment',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substring(start + 2, end)\n    };\n}\n\nexport function generate(node) {\n    this.token(Comment, '/*' + node.value + '*/');\n}\n", "import {\n    WhiteSpace,\n    Comment,\n    Ident,\n    LeftParenthesis,\n    RightParenthesis,\n    Function as FunctionToken,\n    Colon,\n    EOF\n} from '../../tokenizer/index.js';\n\nconst likelyFeatureToken = new Set([Colon, RightParenthesis, EOF]);\n\nexport const name = 'Condition';\nexport const structure = {\n    kind: String,\n    children: [[\n        'Identifier',\n        'Feature',\n        'FeatureFunction',\n        'FeatureRange',\n        'SupportsDeclaration'\n    ]]\n};\n\nfunction featureOrRange(kind) {\n    if (this.lookupTypeNonSC(1) === Ident &&\n        likelyFeatureToken.has(this.lookupTypeNonSC(2))) {\n        return this.Feature(kind);\n    }\n\n    return this.FeatureRange(kind);\n}\n\nconst parentheses = {\n    media: featureOrRange,\n    container: featureOrRange,\n    supports() {\n        return this.SupportsDeclaration();\n    }\n};\n\nexport function parse(kind = 'media') {\n    const children = this.createList();\n\n    scan: while (!this.eof) {\n        switch (this.tokenType) {\n            case Comment:\n            case WhiteSpace:\n                this.next();\n                continue;\n\n            case Ident:\n                children.push(this.Identifier());\n                break;\n\n            case LeftParenthesis: {\n                let term = this.parseWithFallback(\n                    () => parentheses[kind].call(this, kind),\n                    () => null\n                );\n\n                if (!term) {\n                    term = this.parseWithFallback(\n                        () => {\n                            this.eat(LeftParenthesis);\n                            const res = this.Condition(kind);\n                            this.eat(RightParenthesis);\n                            return res;\n                        },\n                        () => {\n                            return this.GeneralEnclosed(kind);\n                        }\n                    );\n                }\n\n                children.push(term);\n                break;\n            }\n\n            case FunctionToken: {\n                let term = this.parseWithFallback(\n                    () => this.FeatureFunction(kind),\n                    () => null\n                );\n\n                if (!term) {\n                    term = this.GeneralEnclosed(kind);\n                }\n\n                children.push(term);\n                break;\n            }\n\n            default:\n                break scan;\n        }\n    }\n\n    if (children.isEmpty) {\n        this.error('Condition is expected');\n    }\n\n    return {\n        type: 'Condition',\n        loc: this.getLocationFromList(children),\n        kind,\n        children\n    };\n}\n\nexport function generate(node) {\n    node.children.forEach(child => {\n        if (child.type === 'Condition') {\n            this.token(LeftParenthesis, '(');\n            this.node(child);\n            this.token(RightParenthesis, ')');\n        } else {\n            this.node(child);\n        }\n    });\n}\n\n", "import { isCustomProperty } from '../../utils/names.js';\nimport {\n    Ident,\n    Hash,\n    Colon,\n    Semicolon,\n    Delim,\n    WhiteSpace\n} from '../../tokenizer/index.js';\n\nconst EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\nconst NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nconst DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\nfunction consumeValueRaw() {\n    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, true);\n}\n\nfunction consumeCustomPropertyRaw() {\n    return this.Raw(this.consumeUntilExclamationMarkOrSemicolon, false);\n}\n\nfunction consumeValue() {\n    const startValueToken = this.tokenIndex;\n    const value = this.Value();\n\n    if (value.type !== 'Raw' &&\n        this.eof === false &&\n        this.tokenType !== Semicolon &&\n        this.isDelim(EXCLAMATIONMARK) === false &&\n        this.isBalanceEdge(startValueToken) === false) {\n        this.error();\n    }\n\n    return value;\n}\n\nexport const name = 'Declaration';\nexport const walkContext = 'declaration';\nexport const structure = {\n    important: [Boolean, String],\n    property: String,\n    value: ['Value', 'Raw']\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const startToken = this.tokenIndex;\n    const property = readProperty.call(this);\n    const customProperty = isCustomProperty(property);\n    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;\n    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;\n    let important = false;\n    let value;\n\n    this.skipSC();\n    this.eat(Colon);\n\n    const valueStart = this.tokenIndex;\n\n    if (!customProperty) {\n        this.skipSC();\n    }\n\n    if (parseValue) {\n        value = this.parseWithFallback(consumeValue, consumeRaw);\n    } else {\n        value = consumeRaw.call(this, this.tokenIndex);\n    }\n\n    if (customProperty && value.type === 'Value' && value.children.isEmpty) {\n        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {\n            if (this.lookupType(offset) === WhiteSpace) {\n                value.children.appendData({\n                    type: 'WhiteSpace',\n                    loc: null,\n                    value: ' '\n                });\n                break;\n            }\n        }\n    }\n\n    if (this.isDelim(EXCLAMATIONMARK)) {\n        important = getImportant.call(this);\n        this.skipSC();\n    }\n\n    // Do not include semicolon to range per spec\n    // https://drafts.csswg.org/css-syntax/#declaration-diagram\n\n    if (this.eof === false &&\n        this.tokenType !== Semicolon &&\n        this.isBalanceEdge(startToken) === false) {\n        this.error();\n    }\n\n    return {\n        type: 'Declaration',\n        loc: this.getLocation(start, this.tokenStart),\n        important,\n        property,\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(Ident, node.property);\n    this.token(Colon, ':');\n    this.node(node.value);\n\n    if (node.important) {\n        this.token(Delim, '!');\n        this.token(Ident, node.important === true ? 'important' : node.important);\n    }\n}\n\nfunction readProperty() {\n    const start = this.tokenStart;\n\n    // hacks\n    if (this.tokenType === Delim) {\n        switch (this.charCodeAt(this.tokenStart)) {\n            case ASTERISK:\n            case DOLLARSIGN:\n            case PLUSSIGN:\n            case NUMBERSIGN:\n            case AMPERSAND:\n                this.next();\n                break;\n\n            // TODO: not sure we should support this hack\n            case SOLIDUS:\n                this.next();\n                if (this.isDelim(SOLIDUS)) {\n                    this.next();\n                }\n                break;\n        }\n    }\n\n    if (this.tokenType === Hash) {\n        this.eat(Hash);\n    } else {\n        this.eat(Ident);\n    }\n\n    return this.substrToCursor(start);\n}\n\n// ! ws* important\nfunction getImportant() {\n    this.eat(Delim);\n    this.skipSC();\n\n    const important = this.consume(Ident);\n\n    // store original value in case it differ from `important`\n    // for better original source restoring and hacks like `!ie` support\n    return important === 'important' ? true : important;\n}\n", "import {\n    WhiteSpace,\n    Comment,\n    Semicolon,\n    AtKeyword\n} from '../../tokenizer/index.js';\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nfunction consumeRaw() {\n    return this.Raw(this.consumeUntilSemicolonIncluded, true);\n}\n\nexport const name = 'DeclarationList';\nexport const structure = {\n    children: [[\n        'Declaration',\n        'Atrule',\n        'Rule'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case WhiteSpace:\n            case Comment:\n            case Semicolon:\n                this.next();\n                break;\n\n            case AtKeyword:\n                children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw));\n                break;\n\n            default:\n                if (this.isDelim(AMPERSAND))  {\n                    children.push(this.parseWithFallback(this.Rule, consumeRaw));\n                } else {\n                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));\n                }\n        }\n    }\n\n    return {\n        type: 'DeclarationList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, prev => {\n        if (prev.type === 'Declaration') {\n            this.token(Semicolon, ';');\n        }\n    });\n}\n\n", "import { Dimension } from '../../tokenizer/index.js';\n\nexport const name = 'Dimension';\nexport const structure = {\n    value: String,\n    unit: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const value = this.consumeNumber(Dimension);\n\n    return {\n        type: 'Dimension',\n        loc: this.getLocation(start, this.tokenStart),\n        value,\n        unit: this.substring(start + value.length, this.tokenStart)\n    };\n}\n\nexport function generate(node) {\n    this.token(Dimension, node.value + node.unit);\n}\n", "import {\n    Ident,\n    Number,\n    Dimension,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis,\n    Colon,\n    Delim\n} from '../../tokenizer/index.js';\n\nconst SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)\n\nexport const name = 'Feature';\nexport const structure = {\n    kind: String,\n    name: String,\n    value: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function', null]\n};\n\nexport function parse(kind) {\n    const start = this.tokenStart;\n    let name;\n    let value = null;\n\n    this.eat(LeftParenthesis);\n    this.skipSC();\n\n    name = this.consume(Ident);\n    this.skipSC();\n\n    if (this.tokenType !== RightParenthesis) {\n        this.eat(Colon);\n        this.skipSC();\n\n        switch (this.tokenType) {\n            case Number:\n                if (this.lookupNonWSType(1) === Delim) {\n                    value = this.Ratio();\n                } else {\n                    value = this.Number();\n                }\n\n                break;\n\n            case Dimension:\n                value = this.Dimension();\n                break;\n\n            case Ident:\n                value = this.Identifier();\n                break;\n\n            case FunctionToken:\n                value = this.parseWithFallback(\n                    () => {\n                        const res = this.Function(this.readSequence, this.scope.Value);\n\n                        this.skipSC();\n\n                        if (this.isDelim(SOLIDUS)) {\n                            this.error();\n                        }\n\n                        return res;\n                    },\n                    () => {\n                        return this.Ratio();\n                    }\n                );\n                break;\n\n            default:\n                this.error('Number, dimension, ratio or identifier is expected');\n        }\n\n        this.skipSC();\n    }\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Feature',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        name,\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.token(Ident, node.name);\n\n    if (node.value !== null) {\n        this.token(Colon, ':');\n        this.node(node.value);\n    }\n\n    this.token(RightParenthesis, ')');\n}\n", "import {\n    Function as FunctionToken,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'FeatureFunction';\nexport const structure = {\n    kind: String,\n    feature: String,\n    value: ['Declaration', 'Selector']\n};\n\nfunction getFeatureParser(kind, name) {\n    const featuresOfKind = this.features[kind] || {};\n    const parser = featuresOfKind[name];\n\n    if (typeof parser !== 'function') {\n        this.error(`Unknown feature ${name}()`);\n    }\n\n    return parser;\n}\n\nexport function parse(kind = 'unknown') {\n    const start = this.tokenStart;\n    const functionName = this.consumeFunctionName();\n    const valueParser = getFeatureParser.call(this, kind, functionName.toLowerCase());\n\n    this.skipSC();\n\n    const value = this.parseWithFallback(\n        () => {\n            const startValueToken = this.tokenIndex;\n            const value = valueParser.call(this);\n\n            if (this.eof === false &&\n                this.isBalanceEdge(startValueToken) === false) {\n                this.error();\n            }\n\n            return value;\n        },\n        () => this.Raw(null, false)\n    );\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'FeatureFunction',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        feature: functionName,\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(FunctionToken, node.feature + '(');\n    this.node(node.value);\n    this.token(RightParenthesis, ')');\n}\n", "import {\n    Ident,\n    Number,\n    Dimension,\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst LESSTHANSIGN = 0x003C;    // U+003C LESS-THAN SIGN (<)\nconst EQUALSSIGN = 0x003D;      // U+003D EQUALS SIGN (=)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\n\nexport const name = 'FeatureRange';\nexport const structure = {\n    kind: String,\n    left: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function'],\n    leftComparison: String,\n    middle: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function'],\n    rightComparison: [String, null],\n    right: ['Identifier', 'Number', 'Dimension', 'Ratio', 'Function', null]\n};\n\nfunction readTerm() {\n    this.skipSC();\n\n    switch (this.tokenType) {\n        case Number:\n            if (this.isDelim(SOLIDUS, this.lookupOffsetNonSC(1))) {\n                return this.Ratio();\n            } else {\n                return this.Number();\n            }\n\n        case Dimension:\n            return this.Dimension();\n\n        case Ident:\n            return this.Identifier();\n\n        case FunctionToken:\n            return this.parseWithFallback(\n                () => {\n                    const res = this.Function(this.readSequence, this.scope.Value);\n\n                    this.skipSC();\n\n                    if (this.isDelim(SOLIDUS)) {\n                        this.error();\n                    }\n\n                    return res;\n                },\n                () => {\n                    return this.Ratio();\n                }\n            );\n\n        default:\n            this.error('Number, dimension, ratio or identifier is expected');\n    }\n}\n\nfunction readComparison(expectColon) {\n    this.skipSC();\n\n    if (this.isDelim(LESSTHANSIGN) ||\n        this.isDelim(GREATERTHANSIGN)) {\n        const value = this.source[this.tokenStart];\n\n        this.next();\n\n        if (this.isDelim(EQUALSSIGN)) {\n            this.next();\n            return value + '=';\n        }\n\n        return value;\n    }\n\n    if (this.isDelim(EQUALSSIGN)) {\n        return '=';\n    }\n\n    this.error(`Expected ${expectColon ? '\":\", ' : ''}\"<\", \">\", \"=\" or \")\"`);\n}\n\nexport function parse(kind = 'unknown') {\n    const start = this.tokenStart;\n\n    this.skipSC();\n    this.eat(LeftParenthesis);\n\n    const left = readTerm.call(this);\n    const leftComparison = readComparison.call(this, left.type === 'Identifier');\n    const middle = readTerm.call(this);\n    let rightComparison = null;\n    let right = null;\n\n    if (this.lookupNonWSType(0) !== RightParenthesis) {\n        rightComparison = readComparison.call(this);\n        right = readTerm.call(this);\n    }\n\n    this.skipSC();\n    this.eat(RightParenthesis);\n\n    return {\n        type: 'FeatureRange',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        left,\n        leftComparison,\n        middle,\n        rightComparison,\n        right\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.node(node.left);\n    this.tokenize(node.leftComparison);\n    this.node(node.middle);\n\n    if (node.right) {\n        this.tokenize(node.rightComparison);\n        this.node(node.right);\n    }\n\n    this.token(RightParenthesis, ')');\n}\n", "import {\n    Function as FunctionToken,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\n\nexport const name = 'Function';\nexport const walkContext = 'function';\nexport const structure = {\n    name: String,\n    children: [[]]\n};\n\n// <function-token> <sequence> )\nexport function parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    const name = this.consumeFunctionName();\n    const nameLowerCase = name.toLowerCase();\n    let children;\n\n    children = recognizer.hasOwnProperty(nameLowerCase)\n        ? recognizer[nameLowerCase].call(this, recognizer)\n        : readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Function',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(FunctionToken, node.name + '(');\n    this.children(node);\n    this.token(RightParenthesis, ')');\n}\n", "import {\n    Function as FunctionToken,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\n\nexport const name = 'GeneralEnclosed';\nexport const structure = {\n    kind: String,\n    function: [String, null],\n    children: [[]]\n};\n\n// <function-token> <any-value> )\n// ( <any-value> )\nexport function parse(kind) {\n    const start = this.tokenStart;\n    let functionName = null;\n\n    if (this.tokenType === FunctionToken) {\n        functionName = this.consumeFunctionName();\n    } else {\n        this.eat(LeftParenthesis);\n    }\n\n    const children = this.parseWithFallback(\n        () => {\n            const startValueToken = this.tokenIndex;\n            const children = this.readSequence(this.scope.Value);\n\n            if (this.eof === false &&\n                this.isBalanceEdge(startValueToken) === false) {\n                this.error();\n            }\n\n            return children;\n        },\n        () => this.createSingleNodeList(\n            this.Raw(null, false)\n        )\n    );\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'GeneralEnclosed',\n        loc: this.getLocation(start, this.tokenStart),\n        kind,\n        function: functionName,\n        children\n    };\n}\n\nexport function generate(node) {\n    if (node.function) {\n        this.token(FunctionToken, node.function + '(');\n    } else {\n        this.token(LeftParenthesis, '(');\n    }\n\n    this.children(node);\n    this.token(RightParenthesis, ')');\n}\n", "import { Hash } from '../../tokenizer/index.js';\n\n// '#' ident\nexport const xxx = 'XXX';\nexport const name = 'Hash';\nexport const structure = {\n    value: String\n};\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(Hash);\n\n    return {\n        type: 'Hash',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start + 1)\n    };\n}\nexport function generate(node) {\n    this.token(Hash, '#' + node.value);\n}\n\n", "import { Ident } from '../../tokenizer/index.js';\n\nexport const name = 'Identifier';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    return {\n        type: 'Identifier',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        name: this.consume(Ident)\n    };\n}\n\nexport function generate(node) {\n    this.token(Ident, node.name);\n}\n", "import { Hash, Delim } from '../../tokenizer/index.js';\n\nexport const name = 'IdSelector';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    // TODO: check value is an ident\n    this.eat(Hash);\n\n    return {\n        type: 'IdSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start + 1)\n    };\n}\n\nexport function generate(node) {\n    // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector\n    // in safe mode (e.g. \"a#id\"), because IE11 doesn't allow a sequence <ident-token> <hash-token>\n    // without a whitespace in values (e.g. \"1px solid#000\")\n    this.token(Delim, '#' + node.name);\n}\n", "import { Ident, Delim } from '../../tokenizer/index.js';\n\nconst FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\nexport const name = 'Layer';\nexport const structure = {\n    name: String\n};\n\nexport function parse() {\n    let name = this.consume(Ident);\n\n    while (this.isDelim(FULLSTOP)) {\n        this.eat(Delim);\n        name += '.' + this.consume(Ident);\n    }\n\n    return {\n        type: 'Layer',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        name\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.name);\n}\n", "import { Comma } from '../../tokenizer/index.js';\n\nexport const name = 'LayerList';\nexport const structure = {\n    children: [[\n        'Layer'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    while (!this.eof) {\n        children.push(this.Layer());\n\n        if (this.lookupTypeNonSC(0) !== Comma) {\n            break;\n        }\n\n        this.skipSC();\n        this.next();\n        this.skipSC();\n    }\n\n    return {\n        type: 'LayerList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, () => this.token(Comma, ','));\n}\n", "import {\n    Comma,\n    EOF,\n    Ident,\n    LeftCurlyBracket,\n    LeftParenthesis,\n    Function as FunctionToken,\n    Semicolon\n} from '../../tokenizer/index.js';\n\nexport const name = 'MediaQuery';\nexport const structure = {\n    modifier: [String, null],\n    mediaType: [String, null],\n    condition: ['Condition', null]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    let modifier = null;\n    let mediaType = null;\n    let condition = null;\n\n    this.skipSC();\n\n    if (this.tokenType === Ident && this.lookupTypeNonSC(1) !== LeftParenthesis) {\n        // [ not | only ]? <media-type>\n        const ident = this.consume(Ident);\n        const identLowerCase = ident.toLowerCase();\n\n        if (identLowerCase === 'not' || identLowerCase === 'only') {\n            this.skipSC();\n            modifier = identLowerCase;\n            mediaType = this.consume(Ident);\n        } else {\n            mediaType = ident;\n        }\n\n        switch (this.lookupTypeNonSC(0)) {\n            case Ident: {\n                // and <media-condition-without-or>\n                this.skipSC();\n                this.eatIdent('and');\n                condition = this.Condition('media');\n                break;\n            }\n\n            case LeftCurlyBracket:\n            case Semicolon:\n            case Comma:\n            case EOF:\n                break;\n\n            default:\n                this.error('Identifier or parenthesis is expected');\n        }\n    } else {\n        switch (this.tokenType) {\n            case Ident:\n            case LeftParenthesis:\n            case FunctionToken: {\n                // <media-condition>\n                condition = this.Condition('media');\n                break;\n            }\n\n            case LeftCurlyBracket:\n            case Semicolon:\n            case EOF:\n                break;\n\n            default:\n                this.error('Identifier or parenthesis is expected');\n        }\n    }\n\n    return {\n        type: 'MediaQuery',\n        loc: this.getLocation(start, this.tokenStart),\n        modifier,\n        mediaType,\n        condition\n    };\n}\n\nexport function generate(node) {\n    if (node.mediaType) {\n        if (node.modifier) {\n            this.token(Ident, node.modifier);\n        }\n\n        this.token(Ident, node.mediaType);\n\n        if (node.condition) {\n            this.token(Ident, 'and');\n            this.node(node.condition);\n        }\n    } else if (node.condition) {\n        this.node(node.condition);\n    }\n}\n\n", "import { Comma } from '../../tokenizer/index.js';\n\nexport const name = 'MediaQueryList';\nexport const structure = {\n    children: [[\n        'MediaQuery'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    while (!this.eof) {\n        children.push(this.MediaQuery());\n\n        if (this.tokenType !== Comma) {\n            break;\n        }\n\n        this.next();\n    }\n\n    return {\n        type: 'MediaQueryList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, () => this.token(Comma, ','));\n}\n", "import { Delim } from '../../tokenizer/index.js';\n\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\n\nexport const name = 'NestingSelector';\nexport const structure = {\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eatDelim(AMPERSAND);\n\n    return {\n        type: 'NestingSelector',\n        loc: this.getLocation(start, this.tokenStart)\n    };\n}\n\nexport function generate() {\n    this.token(Delim, '&');\n}\n", "import { Ident } from '../../tokenizer/index.js';\n\nexport const name = 'Nth';\nexport const structure = {\n    nth: ['AnPlusB', 'Identifier'],\n    selector: ['SelectorList', null]\n};\n\nexport function parse() {\n    this.skipSC();\n\n    const start = this.tokenStart;\n    let end = start;\n    let selector = null;\n    let nth;\n\n    if (this.lookupValue(0, 'odd') || this.lookupValue(0, 'even')) {\n        nth = this.Identifier();\n    } else {\n        nth = this.AnPlusB();\n    }\n\n    end = this.tokenStart;\n    this.skipSC();\n\n    if (this.lookupValue(0, 'of')) {\n        this.next();\n\n        selector = this.SelectorList();\n        end = this.tokenStart;\n    }\n\n    return {\n        type: 'Nth',\n        loc: this.getLocation(start, end),\n        nth,\n        selector\n    };\n}\n\nexport function generate(node) {\n    this.node(node.nth);\n    if (node.selector !== null) {\n        this.token(Ident, 'of');\n        this.node(node.selector);\n    }\n}\n", "import { Number as NumberToken } from '../../tokenizer/index.js';\n\nexport const name = 'Number';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    return {\n        type: 'Number',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: this.consume(NumberToken)\n    };\n}\n\nexport function generate(node) {\n    this.token(NumberToken, node.value);\n}\n", "// '/' | '*' | ',' | ':' | '+' | '-'\nexport const name = 'Operator';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.next();\n\n    return {\n        type: 'Operator',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.value);\n}\n", "import {\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'Parentheses';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse(readSequence, recognizer) {\n    const start = this.tokenStart;\n    let children = null;\n\n    this.eat(LeftParenthesis);\n\n    children = readSequence.call(this, recognizer);\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Parentheses',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.children(node);\n    this.token(RightParenthesis, ')');\n}\n", "import { Percentage } from '../../tokenizer/index.js';\n\nexport const name = 'Percentage';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    return {\n        type: 'Percentage',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: this.consumeNumber(Percentage)\n    };\n}\n\nexport function generate(node) {\n    this.token(Percentage, node.value + '%');\n}\n", "import {\n    Ident,\n    Function as FunctionToken,\n    Colon,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\n\nexport const name = 'PseudoClassSelector';\nexport const walkContext = 'function';\nexport const structure = {\n    name: String,\n    children: [['Raw'], null]\n};\n\n// : [ <ident> | <function-token> <any-value>? ) ]\nexport function parse() {\n    const start = this.tokenStart;\n    let children = null;\n    let name;\n    let nameLowerCase;\n\n    this.eat(Colon);\n\n    if (this.tokenType === FunctionToken) {\n        name = this.consumeFunctionName();\n        nameLowerCase = name.toLowerCase();\n\n        if (this.lookupNonWSType(0) == RightParenthesis) {\n            children = this.createList();\n        } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {\n            this.skipSC();\n            children = this.pseudo[nameLowerCase].call(this);\n            this.skipSC();\n        } else {\n            children = this.createList();\n            children.push(\n                this.Raw(null, false)\n            );\n        }\n\n        this.eat(RightParenthesis);\n    } else {\n        name = this.consume(Ident);\n    }\n\n    return {\n        type: 'PseudoClassSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(Colon, ':');\n\n    if (node.children === null) {\n        this.token(Ident, node.name);\n    } else {\n        this.token(FunctionToken, node.name + '(');\n        this.children(node);\n        this.token(RightParenthesis, ')');\n    }\n}\n", "import {\n    Ident,\n    Function as FunctionToken,\n    Colon,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'PseudoElementSelector';\nexport const walkContext = 'function';\nexport const structure = {\n    name: String,\n    children: [['Raw'], null]\n};\n\n// :: [ <ident> | <function-token> <any-value>? ) ]\nexport function parse() {\n    const start = this.tokenStart;\n    let children = null;\n    let name;\n    let nameLowerCase;\n\n    this.eat(Colon);\n    this.eat(Colon);\n\n    if (this.tokenType === FunctionToken) {\n        name = this.consumeFunctionName();\n        nameLowerCase = name.toLowerCase();\n\n        if (this.lookupNonWSType(0) == RightParenthesis) {\n            children = this.createList();\n        } else if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {\n            this.skipSC();\n            children = this.pseudo[nameLowerCase].call(this);\n            this.skipSC();\n        } else {\n            children = this.createList();\n            children.push(\n                this.Raw(null, false)\n            );\n        }\n\n        this.eat(RightParenthesis);\n    } else {\n        name = this.consume(Ident);\n    }\n\n    return {\n        type: 'PseudoElementSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name,\n        children\n    };\n}\n\nexport function generate(node) {\n    this.token(Colon, ':');\n    this.token(Colon, ':');\n\n    if (node.children === null) {\n        this.token(Ident, node.name);\n    } else {\n        this.token(FunctionToken, node.name + '(');\n        this.children(node);\n        this.token(RightParenthesis, ')');\n    }\n}\n", "import {\n    Delim,\n    Number as NumberToken,\n    Function as FunctionToken\n} from '../../tokenizer/index.js';\n\nconst SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)\n\n// Media Queries Level 3 defines terms of <ratio> as a positive (not zero or negative)\n// integers (see https://drafts.csswg.org/mediaqueries-3/#values)\n// However, Media Queries Level 4 removes any definition of values\n// (see https://drafts.csswg.org/mediaqueries-4/#values) and refers to\n// CSS Values and Units for detail. In CSS Values and Units Level 4 a <ratio>\n// definition was added (see https://drafts.csswg.org/css-values-4/#ratios) which\n// defines ratio as \"<number [0,\u221E]> [ / <number [0,\u221E]> ]?\" and based on it\n// any constrains on terms were removed. Parser also doesn't test numbers\n// in any way to make possible for linting and fixing them by the tools using CSSTree.\n// An additional syntax examination may be applied by a lexer.\nfunction consumeTerm() {\n    this.skipSC();\n\n    switch (this.tokenType) {\n        case NumberToken:\n            return this.Number();\n\n        case FunctionToken:\n            return this.Function(this.readSequence, this.scope.Value);\n\n        default:\n            this.error('Number of function is expected');\n    }\n}\n\nexport const name = 'Ratio';\nexport const structure = {\n    left: ['Number', 'Function'],\n    right: ['Number', 'Function', null]\n};\n\n// <number [0,\u221E]> [ / <number [0,\u221E]> ]?\nexport function parse() {\n    const start = this.tokenStart;\n    const left = consumeTerm.call(this);\n    let right = null;\n\n    this.skipSC();\n    if (this.isDelim(SOLIDUS)) {\n        this.eatDelim(SOLIDUS);\n        right = consumeTerm.call(this);\n    }\n\n    return {\n        type: 'Ratio',\n        loc: this.getLocation(start, this.tokenStart),\n        left,\n        right\n    };\n}\n\nexport function generate(node) {\n    this.node(node.left);\n    this.token(Delim, '/');\n    if (node.right) {\n        this.node(node.right);\n    } else {\n        this.node(NumberToken, 1);\n    }\n}\n", "import { WhiteSpace } from '../../tokenizer/index.js';\n\nfunction getOffsetExcludeWS() {\n    if (this.tokenIndex > 0) {\n        if (this.lookupType(-1) === WhiteSpace) {\n            return this.tokenIndex > 1\n                ? this.getTokenStart(this.tokenIndex - 1)\n                : this.firstCharOffset;\n        }\n    }\n\n    return this.tokenStart;\n}\n\nexport const name = 'Raw';\nexport const structure = {\n    value: String\n};\n\nexport function parse(consumeUntil, excludeWhiteSpace) {\n    const startOffset = this.getTokenStart(this.tokenIndex);\n    let endOffset;\n\n    this.skipUntilBalanced(this.tokenIndex, consumeUntil || this.consumeUntilBalanceEnd);\n\n    if (excludeWhiteSpace && this.tokenStart > startOffset) {\n        endOffset = getOffsetExcludeWS.call(this);\n    } else {\n        endOffset = this.tokenStart;\n    }\n\n    return {\n        type: 'Raw',\n        loc: this.getLocation(startOffset, endOffset),\n        value: this.substring(startOffset, endOffset)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.value);\n}\n", "import { LeftCurlyBracket, RightCurlyBracket } from '../../tokenizer/index.js';\n\nfunction consumeRaw() {\n    return this.Raw(this.consumeUntilLeftCurlyBracket, true);\n}\n\nfunction consumePrelude() {\n    const prelude = this.SelectorList();\n\n    if (prelude.type !== 'Raw' &&\n        this.eof === false &&\n        this.tokenType !== LeftCurlyBracket) {\n        this.error();\n    }\n\n    return prelude;\n}\n\nexport const name = 'Rule';\nexport const walkContext = 'rule';\nexport const structure = {\n    prelude: ['SelectorList', 'Raw'],\n    block: ['Block']\n};\n\nexport function parse() {\n    const startToken = this.tokenIndex;\n    const startOffset = this.tokenStart;\n    let prelude;\n    let block;\n\n    if (this.parseRulePrelude) {\n        prelude = this.parseWithFallback(consumePrelude, consumeRaw);\n    } else {\n        prelude = consumeRaw.call(this, startToken);\n    }\n\n    this.skipSC();\n    this.eat(LeftCurlyBracket);\n\n    block = this.Block(true);\n\n    if (!this.eof) {\n        this.eat(RightCurlyBracket);\n    }\n\n    return {\n        type: 'Rule',\n        loc: this.getLocation(startOffset, this.tokenStart),\n        prelude,\n        block\n    };\n}\nexport function generate(node) {\n    this.node(node.prelude);\n    this.token(LeftCurlyBracket, '{');\n    this.node(node.block);\n    this.token(RightCurlyBracket, '}');\n}\n\n", "import {\n    Ident,\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'Scope';\nexport const structure = {\n    root: ['SelectorList', 'Raw', null],\n    limit: ['SelectorList', 'Raw', null]\n};\n\nexport function parse() {\n    let root = null;\n    let limit = null;\n\n    this.skipSC();\n\n    const startOffset = this.tokenStart;\n    if (this.tokenType === LeftParenthesis) {\n        this.next();\n        this.skipSC();\n        root = this.parseWithFallback(\n            this.SelectorList,\n            () => this.Raw(false, true)\n        );\n        this.skipSC();\n        this.eat(RightParenthesis);\n    }\n\n    if (this.lookupNonWSType(0) === Ident) {\n        this.skipSC();\n        this.eatIdent('to');\n        this.skipSC();\n        this.eat(LeftParenthesis);\n        this.skipSC();\n        limit = this.parseWithFallback(\n            this.SelectorList,\n            () => this.Raw(false, true)\n        );\n        this.skipSC();\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'Scope',\n        loc: this.getLocation(startOffset, this.tokenStart),\n        root,\n        limit\n    };\n}\n\nexport function generate(node) {\n    if (node.root) {\n        this.token(LeftParenthesis, '(');\n        this.node(node.root);\n        this.token(RightParenthesis, ')');\n    }\n\n    if (node.limit) {\n        this.token(Ident, 'to');\n        this.token(LeftParenthesis, '(');\n        this.node(node.limit);\n        this.token(RightParenthesis, ')');\n    }\n}\n", "export const name = 'Selector';\nexport const structure = {\n    children: [[\n        'TypeSelector',\n        'IdSelector',\n        'ClassSelector',\n        'AttributeSelector',\n        'PseudoClassSelector',\n        'PseudoElementSelector',\n        'Combinator'\n    ]]\n};\n\nexport function parse() {\n    const children = this.readSequence(this.scope.Selector);\n\n    // nothing were consumed\n    if (this.getFirstListNode(children) === null) {\n        this.error('Selector is expected');\n    }\n\n    return {\n        type: 'Selector',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n", "import { Comma } from '../../tokenizer/index.js';\n\nexport const name = 'SelectorList';\nexport const walkContext = 'selector';\nexport const structure = {\n    children: [[\n        'Selector',\n        'Raw'\n    ]]\n};\n\nexport function parse() {\n    const children = this.createList();\n\n    while (!this.eof) {\n        children.push(this.Selector());\n\n        if (this.tokenType === Comma) {\n            this.next();\n            continue;\n        }\n\n        break;\n    }\n\n    return {\n        type: 'SelectorList',\n        loc: this.getLocationFromList(children),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node, () => this.token(Comma, ','));\n}\n", "import {\n    isHexDigit,\n    isWhiteSpace,\n    isValidEscape,\n    consumeEscaped,\n    decodeEscaped\n} from '../tokenizer/index.js';\n\nconst REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022;  // \"\nconst APOSTROPHE = 0x0027;      // '\n\nexport function decode(str) {\n    const len = str.length;\n    const firstChar = str.charCodeAt(0);\n    const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;\n    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;\n    let decoded = '';\n\n    for (let i = start; i <= end; i++) {\n        let code = str.charCodeAt(i);\n\n        if (code === REVERSE_SOLIDUS) {\n            // special case at the ending\n            if (i === end) {\n                // if the next input code point is EOF, do nothing\n                // otherwise include last quote as escaped\n                if (i !== len - 1) {\n                    decoded = str.substr(i + 1);\n                }\n                break;\n            }\n\n            code = str.charCodeAt(++i);\n\n            // consume escaped\n            if (isValidEscape(REVERSE_SOLIDUS, code)) {\n                const escapeStart = i - 1;\n                const escapeEnd = consumeEscaped(str, escapeStart);\n\n                i = escapeEnd - 1;\n                decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n            } else {\n                // \\r\\n\n                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n                    i++;\n                }\n            }\n        } else {\n            decoded += str[i];\n        }\n    }\n\n    return decoded;\n}\n\n// https://drafts.csswg.org/cssom/#serialize-a-string\n// \u00A7 2.1. Common Serializing Idioms\nexport function encode(str, apostrophe) {\n    const quote = apostrophe ? '\\'' : '\"';\n    const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;\n    let encoded = '';\n    let wsBeforeHexIsNeeded = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n        if (code === 0x0000) {\n            encoded += '\\uFFFD';\n            continue;\n        }\n\n        // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n        // the character escaped as code point.\n        // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n        if (code <= 0x001f || code === 0x007F) {\n            encoded += '\\\\' + code.toString(16);\n            wsBeforeHexIsNeeded = true;\n            continue;\n        }\n\n        // If the character is '\"' (U+0022) or \"\\\" (U+005C), the escaped character.\n        if (code === quoteCode || code === REVERSE_SOLIDUS) {\n            encoded += '\\\\' + str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        } else {\n            if (wsBeforeHexIsNeeded && (isHexDigit(code) || isWhiteSpace(code))) {\n                encoded += ' ';\n            }\n\n            // Otherwise, the character itself.\n            encoded += str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        }\n    }\n\n    return quote + encoded + quote;\n}\n", "import { String as StringToken } from '../../tokenizer/index.js';\nimport { decode, encode } from '../../utils/string.js';\n\nexport const name = 'String';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    return {\n        type: 'String',\n        loc: this.getLocation(this.tokenStart, this.tokenEnd),\n        value: decode(this.consume(StringToken))\n    };\n}\n\nexport function generate(node) {\n    this.token(StringToken, encode(node.value));\n}\n", "import {\n    WhiteSpace,\n    Comment,\n    AtKeyword,\n    CDO,\n    CDC\n} from '../../tokenizer/index.js';\n\nconst EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\nfunction consumeRaw() {\n    return this.Raw(null, false);\n}\n\nexport const name = 'StyleSheet';\nexport const walkContext = 'stylesheet';\nexport const structure = {\n    children: [[\n        'Comment',\n        'CDO',\n        'CDC',\n        'Atrule',\n        'Rule',\n        'Raw'\n    ]]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const children = this.createList();\n    let child;\n\n    scan:\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case WhiteSpace:\n                this.next();\n                continue;\n\n            case Comment:\n                // ignore comments except exclamation comments (i.e. /*! .. */) on top level\n                if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {\n                    this.next();\n                    continue;\n                }\n\n                child = this.Comment();\n                break;\n\n            case CDO: // <!--\n                child = this.CDO();\n                break;\n\n            case CDC: // -->\n                child = this.CDC();\n                break;\n\n            // CSS Syntax Module Level 3\n            // \u00A72.2 Error handling\n            // At the \"top level\" of a stylesheet, an <at-keyword-token> starts an at-rule.\n            case AtKeyword:\n                child = this.parseWithFallback(this.Atrule, consumeRaw);\n                break;\n\n            // Anything else starts a qualified rule ...\n            default:\n                child = this.parseWithFallback(this.Rule, consumeRaw);\n        }\n\n        children.push(child);\n    }\n\n    return {\n        type: 'StyleSheet',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n", "import {\n    LeftParenthesis,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'SupportsDeclaration';\nexport const structure = {\n    declaration: 'Declaration'\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    this.eat(LeftParenthesis);\n    this.skipSC();\n\n    const declaration = this.Declaration();\n\n    if (!this.eof) {\n        this.eat(RightParenthesis);\n    }\n\n    return {\n        type: 'SupportsDeclaration',\n        loc: this.getLocation(start, this.tokenStart),\n        declaration\n    };\n}\n\nexport function generate(node) {\n    this.token(LeftParenthesis, '(');\n    this.node(node.declaration);\n    this.token(RightParenthesis, ')');\n}\n", "import { Ident } from '../../tokenizer/index.js';\n\nconst ASTERISK = 0x002A;     // U+002A ASTERISK (*)\nconst VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)\n\nfunction eatIdentifierOrAsterisk() {\n    if (this.tokenType !== Ident &&\n        this.isDelim(ASTERISK) === false) {\n        this.error('Identifier or asterisk is expected');\n    }\n\n    this.next();\n}\n\nexport const name = 'TypeSelector';\nexport const structure = {\n    name: String\n};\n\n// ident\n// ident|ident\n// ident|*\n// *\n// *|ident\n// *|*\n// |ident\n// |*\nexport function parse() {\n    const start = this.tokenStart;\n\n    if (this.isDelim(VERTICALLINE)) {\n        this.next();\n        eatIdentifierOrAsterisk.call(this);\n    } else {\n        eatIdentifierOrAsterisk.call(this);\n\n        if (this.isDelim(VERTICALLINE)) {\n            this.next();\n            eatIdentifierOrAsterisk.call(this);\n        }\n    }\n\n    return {\n        type: 'TypeSelector',\n        loc: this.getLocation(start, this.tokenStart),\n        name: this.substrToCursor(start)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.name);\n}\n", "import {\n    isHexDigit,\n    Ident,\n    Number,\n    Dimension\n} from '../../tokenizer/index.js';\n\nconst PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)\nconst HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)\nconst QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\n\nfunction eatHexSequence(offset, allowDash) {\n    let len = 0;\n\n    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {\n        const code = this.charCodeAt(pos);\n\n        if (code === HYPHENMINUS && allowDash && len !== 0) {\n            eatHexSequence.call(this, offset + len + 1, false);\n            return -1;\n        }\n\n        if (!isHexDigit(code)) {\n            this.error(\n                allowDash && len !== 0\n                    ? 'Hyphen minus' + (len < 6 ? ' or hex digit' : '') + ' is expected'\n                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),\n                pos\n            );\n        }\n\n        if (++len > 6) {\n            this.error('Too many hex digits', pos);\n        };\n    }\n\n    this.next();\n    return len;\n}\n\nfunction eatQuestionMarkSequence(max) {\n    let count = 0;\n\n    while (this.isDelim(QUESTIONMARK)) {\n        if (++count > max) {\n            this.error('Too many question marks');\n        }\n\n        this.next();\n    }\n}\n\nfunction startsWith(code) {\n    if (this.charCodeAt(this.tokenStart) !== code) {\n        this.error((code === PLUSSIGN ? 'Plus sign' : 'Hyphen minus') + ' is expected');\n    }\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nfunction scanUnicodeRange() {\n    let hexLength = 0;\n\n    switch (this.tokenType) {\n        case Number:\n            // u <number-token> '?'*\n            // u <number-token> <dimension-token>\n            // u <number-token> <number-token>\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (this.isDelim(QUESTIONMARK)) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n                break;\n            }\n\n            if (this.tokenType === Dimension ||\n                this.tokenType === Number) {\n                startsWith.call(this, HYPHENMINUS);\n                eatHexSequence.call(this, 1, false);\n                break;\n            }\n\n            break;\n\n        case Dimension:\n            // u <dimension-token> '?'*\n            hexLength = eatHexSequence.call(this, 1, true);\n\n            if (hexLength > 0) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n            }\n\n            break;\n\n        default:\n            // u '+' <ident-token> '?'*\n            // u '+' '?'+\n            this.eatDelim(PLUSSIGN);\n\n            if (this.tokenType === Ident) {\n                hexLength = eatHexSequence.call(this, 0, true);\n                if (hexLength > 0) {\n                    eatQuestionMarkSequence.call(this, 6 - hexLength);\n                }\n                break;\n            }\n\n            if (this.isDelim(QUESTIONMARK)) {\n                this.next();\n                eatQuestionMarkSequence.call(this, 5);\n                break;\n            }\n\n            this.error('Hex digit or question mark is expected');\n    }\n}\n\nexport const name = 'UnicodeRange';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n\n    // U or u\n    this.eatIdent('u');\n    scanUnicodeRange.call(this);\n\n    return {\n        type: 'UnicodeRange',\n        loc: this.getLocation(start, this.tokenStart),\n        value: this.substrToCursor(start)\n    };\n}\n\nexport function generate(node) {\n    this.tokenize(node.value);\n}\n", "import {\n    isHexDigit,\n    isWhiteSpace,\n    isValidEscape,\n    consumeEscaped,\n    decodeEscaped\n} from '../tokenizer/index.js';\n\nconst SPACE = 0x0020;            // U+0020 SPACE\nconst REVERSE_SOLIDUS = 0x005c;  // U+005C REVERSE SOLIDUS (\\)\nconst QUOTATION_MARK = 0x0022;   // \"\nconst APOSTROPHE = 0x0027;       // '\nconst LEFTPARENTHESIS = 0x0028;  // U+0028 LEFT PARENTHESIS (()\nconst RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())\n\nexport function decode(str) {\n    const len = str.length;\n    let start = 4; // length of \"url(\"\n    let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;\n    let decoded = '';\n\n    while (start < end && isWhiteSpace(str.charCodeAt(start))) {\n        start++;\n    }\n\n    while (start < end && isWhiteSpace(str.charCodeAt(end))) {\n        end--;\n    }\n\n    for (let i = start; i <= end; i++) {\n        let code = str.charCodeAt(i);\n\n        if (code === REVERSE_SOLIDUS) {\n            // special case at the ending\n            if (i === end) {\n                // if the next input code point is EOF, do nothing\n                // otherwise include last left parenthesis as escaped\n                if (i !== len - 1) {\n                    decoded = str.substr(i + 1);\n                }\n                break;\n            }\n\n            code = str.charCodeAt(++i);\n\n            // consume escaped\n            if (isValidEscape(REVERSE_SOLIDUS, code)) {\n                const escapeStart = i - 1;\n                const escapeEnd = consumeEscaped(str, escapeStart);\n\n                i = escapeEnd - 1;\n                decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));\n            } else {\n                // \\r\\n\n                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {\n                    i++;\n                }\n            }\n        } else {\n            decoded += str[i];\n        }\n    }\n\n    return decoded;\n}\n\nexport function encode(str) {\n    let encoded = '';\n    let wsBeforeHexIsNeeded = false;\n\n    for (let i = 0; i < str.length; i++) {\n        const code = str.charCodeAt(i);\n\n        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).\n        if (code === 0x0000) {\n            encoded += '\\uFFFD';\n            continue;\n        }\n\n        // If the character is in the range [\\1-\\1f] (U+0001 to U+001F) or is U+007F,\n        // the character escaped as code point.\n        // Note: Do not compare with 0x0001 since 0x0000 is precessed before\n        if (code <= 0x001f || code === 0x007F) {\n            encoded += '\\\\' + code.toString(16);\n            wsBeforeHexIsNeeded = true;\n            continue;\n        }\n\n        if (code === SPACE ||\n            code === REVERSE_SOLIDUS ||\n            code === QUOTATION_MARK ||\n            code === APOSTROPHE ||\n            code === LEFTPARENTHESIS ||\n            code === RIGHTPARENTHESIS) {\n            encoded += '\\\\' + str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        } else {\n            if (wsBeforeHexIsNeeded && isHexDigit(code)) {\n                encoded += ' ';\n            }\n\n            encoded += str.charAt(i);\n            wsBeforeHexIsNeeded = false;\n        }\n    }\n\n    return 'url(' + encoded + ')';\n}\n", "import * as url from '../../utils/url.js';\nimport * as string from '../../utils/string.js';\nimport {\n    Function as FunctionToken,\n    String as StringToken,\n    Url,\n    RightParenthesis\n} from '../../tokenizer/index.js';\n\nexport const name = 'Url';\nexport const structure = {\n    value: String\n};\n\n// <url-token> | <function-token> <string> )\nexport function parse() {\n    const start = this.tokenStart;\n    let value;\n\n    switch (this.tokenType) {\n        case Url:\n            value = url.decode(this.consume(Url));\n            break;\n\n        case FunctionToken:\n            if (!this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')) {\n                this.error('Function name must be `url`');\n            }\n\n            this.eat(FunctionToken);\n            this.skipSC();\n            value = string.decode(this.consume(StringToken));\n            this.skipSC();\n            if (!this.eof) {\n                this.eat(RightParenthesis);\n            }\n            break;\n\n        default:\n            this.error('Url or Function is expected');\n    }\n\n    return {\n        type: 'Url',\n        loc: this.getLocation(start, this.tokenStart),\n        value\n    };\n}\n\nexport function generate(node) {\n    this.token(Url, url.encode(node.value));\n}\n", "export const name = 'Value';\nexport const structure = {\n    children: [[]]\n};\n\nexport function parse() {\n    const start = this.tokenStart;\n    const children = this.readSequence(this.scope.Value);\n\n    return {\n        type: 'Value',\n        loc: this.getLocation(start, this.tokenStart),\n        children\n    };\n}\n\nexport function generate(node) {\n    this.children(node);\n}\n", "import { WhiteSpace } from '../../tokenizer/index.js';\n\nconst SPACE = Object.freeze({\n    type: 'WhiteSpace',\n    loc: null,\n    value: ' '\n});\n\nexport const name = 'WhiteSpace';\nexport const structure = {\n    value: String\n};\n\nexport function parse() {\n    this.eat(WhiteSpace);\n    return SPACE;\n\n    // return {\n    //     type: 'WhiteSpace',\n    //     loc: this.getLocation(this.tokenStart, this.tokenEnd),\n    //     value: this.consume(WHITESPACE)\n    // };\n}\n\nexport function generate(node) {\n    this.token(WhiteSpace, node.value);\n}\n", "import * as node from '../node/index-generate.js';\n\nexport default {\n    node\n};\n", "import { createGenerator } from './create.js';\nimport config from '../syntax/config/generator.js';\n\nexport default createGenerator(config);\n", "//\n//                              list\n//                            \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//             \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500head \u2502\n//             \u2502              \u2502 tail\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//             \u2502              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2502\n//             \u25BC                                    \u25BC\n//            item        item        item        item\n//          \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n//  null \u25C0\u2500\u2500\u253C\u2500prev \u2502\u25C0\u2500\u2500\u2500\u253C\u2500prev \u2502\u25C0\u2500\u2500\u2500\u253C\u2500prev \u2502\u25C0\u2500\u2500\u2500\u253C\u2500prev \u2502\n//          \u2502 next\u2500\u253C\u2500\u2500\u2500\u25B6\u2502 next\u2500\u253C\u2500\u2500\u2500\u25B6\u2502 next\u2500\u253C\u2500\u2500\u2500\u25B6\u2502 next\u2500\u253C\u2500\u2500\u25B6 null\n//          \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n//          \u2502 data \u2502    \u2502 data \u2502    \u2502 data \u2502    \u2502 data \u2502\n//          \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//\n\nlet releasedCursors = null;\n\nexport class List {\n    static createItem(data) {\n        return {\n            prev: null,\n            next: null,\n            data\n        };\n    }\n\n    constructor() {\n        this.head = null;\n        this.tail = null;\n        this.cursor = null;\n    }\n    createItem(data) {\n        return List.createItem(data);\n    }\n\n    // cursor helpers\n    allocateCursor(prev, next) {\n        let cursor;\n\n        if (releasedCursors !== null) {\n            cursor = releasedCursors;\n            releasedCursors = releasedCursors.cursor;\n            cursor.prev = prev;\n            cursor.next = next;\n            cursor.cursor = this.cursor;\n        } else {\n            cursor = {\n                prev,\n                next,\n                cursor: this.cursor\n            };\n        }\n\n        this.cursor = cursor;\n\n        return cursor;\n    }\n    releaseCursor() {\n        const { cursor } = this;\n\n        this.cursor = cursor.cursor;\n        cursor.prev = null;\n        cursor.next = null;\n        cursor.cursor = releasedCursors;\n        releasedCursors = cursor;\n    }\n    updateCursors(prevOld, prevNew, nextOld, nextNew) {\n        let { cursor } = this;\n\n        while (cursor !== null) {\n            if (cursor.prev === prevOld) {\n                cursor.prev = prevNew;\n            }\n\n            if (cursor.next === nextOld) {\n                cursor.next = nextNew;\n            }\n\n            cursor = cursor.cursor;\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            yield cursor.data;\n        }\n    }\n\n    // getters\n    get size() {\n        let size = 0;\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            size++;\n        }\n\n        return size;\n    }\n    get isEmpty() {\n        return this.head === null;\n    }\n    get first() {\n        return this.head && this.head.data;\n    }\n    get last() {\n        return this.tail && this.tail.data;\n    }\n\n    // convertors\n    fromArray(array) {\n        let cursor = null;\n        this.head = null;\n\n        for (let data of array) {\n            const item = List.createItem(data);\n\n            if (cursor !== null) {\n                cursor.next = item;\n            } else {\n                this.head = item;\n            }\n\n            item.prev = cursor;\n            cursor = item;\n        }\n\n        this.tail = cursor;\n        return this;\n    }\n    toArray() {\n        return [...this];\n    }\n    toJSON() {\n        return [...this];\n    }\n\n    // array-like methods\n    forEach(fn, thisArg = this) {\n        // push cursor\n        const cursor = this.allocateCursor(null, this.head);\n\n        while (cursor.next !== null) {\n            const item = cursor.next;\n            cursor.next = item.next;\n            fn.call(thisArg, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    forEachRight(fn, thisArg = this) {\n        // push cursor\n        const cursor = this.allocateCursor(this.tail, null);\n\n        while (cursor.prev !== null) {\n            const item = cursor.prev;\n            cursor.prev = item.prev;\n            fn.call(thisArg, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    reduce(fn, initialValue, thisArg = this) {\n        // push cursor\n        let cursor = this.allocateCursor(null, this.head);\n        let acc = initialValue;\n        let item;\n\n        while (cursor.next !== null) {\n            item = cursor.next;\n            cursor.next = item.next;\n\n            acc = fn.call(thisArg, acc, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n\n        return acc;\n    }\n    reduceRight(fn, initialValue, thisArg = this) {\n        // push cursor\n        let cursor = this.allocateCursor(this.tail, null);\n        let acc = initialValue;\n        let item;\n\n        while (cursor.prev !== null) {\n            item = cursor.prev;\n            cursor.prev = item.prev;\n\n            acc = fn.call(thisArg, acc, item.data, item, this);\n        }\n\n        // pop cursor\n        this.releaseCursor();\n\n        return acc;\n    }\n    some(fn, thisArg = this) {\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            if (fn.call(thisArg, cursor.data, cursor, this)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n    map(fn, thisArg = this) {\n        const result = new List();\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            result.appendData(fn.call(thisArg, cursor.data, cursor, this));\n        }\n\n        return result;\n    }\n    filter(fn, thisArg = this) {\n        const result = new List();\n\n        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {\n            if (fn.call(thisArg, cursor.data, cursor, this)) {\n                result.appendData(cursor.data);\n            }\n        }\n\n        return result;\n    }\n\n    nextUntil(start, fn, thisArg = this) {\n        if (start === null) {\n            return;\n        }\n\n        // push cursor\n        const cursor = this.allocateCursor(null, start);\n\n        while (cursor.next !== null) {\n            const item = cursor.next;\n            cursor.next = item.next;\n            if (fn.call(thisArg, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n    prevUntil(start, fn, thisArg = this) {\n        if (start === null) {\n            return;\n        }\n\n        // push cursor\n        const cursor = this.allocateCursor(start, null);\n\n        while (cursor.prev !== null) {\n            const item = cursor.prev;\n            cursor.prev = item.prev;\n            if (fn.call(thisArg, item.data, item, this)) {\n                break;\n            }\n        }\n\n        // pop cursor\n        this.releaseCursor();\n    }\n\n    // mutation\n    clear() {\n        this.head = null;\n        this.tail = null;\n    }\n    copy() {\n        const result = new List();\n\n        for (let data of this) {\n            result.appendData(data);\n        }\n\n        return result;\n    }\n    prepend(item) {\n        //      head\n        //    ^\n        // item\n        this.updateCursors(null, item, this.head, item);\n\n        // insert to the beginning of the list\n        if (this.head !== null) {\n            // new item <- first item\n            this.head.prev = item;\n            // new item -> first item\n            item.next = this.head;\n        } else {\n            // if list has no head, then it also has no tail\n            // in this case tail points to the new item\n            this.tail = item;\n        }\n\n        // head always points to new item\n        this.head = item;\n        return this;\n    }\n    prependData(data) {\n        return this.prepend(List.createItem(data));\n    }\n    append(item) {\n        return this.insert(item);\n    }\n    appendData(data) {\n        return this.insert(List.createItem(data));\n    }\n    insert(item, before = null) {\n        if (before !== null) {\n            // prev   before\n            //      ^\n            //     item\n            this.updateCursors(before.prev, item, before, item);\n\n            if (before.prev === null) {\n                // insert to the beginning of list\n                if (this.head !== before) {\n                    throw new Error('before doesn\\'t belong to list');\n                }\n                // since head points to before therefore list doesn't empty\n                // no need to check tail\n                this.head = item;\n                before.prev = item;\n                item.next = before;\n                this.updateCursors(null, item);\n            } else {\n                // insert between two items\n                before.prev.next = item;\n                item.prev = before.prev;\n                before.prev = item;\n                item.next = before;\n            }\n        } else {\n            // tail\n            //      ^\n            //      item\n            this.updateCursors(this.tail, item, null, item);\n\n            // insert to the ending of the list\n            if (this.tail !== null) {\n                // last item -> new item\n                this.tail.next = item;\n                // last item <- new item\n                item.prev = this.tail;\n            } else {\n                // if list has no tail, then it also has no head\n                // in this case head points to new item\n                this.head = item;\n            }\n\n            // tail always points to new item\n            this.tail = item;\n        }\n\n        return this;\n    }\n    insertData(data, before) {\n        return this.insert(List.createItem(data), before);\n    }\n    remove(item) {\n        //      item\n        //       ^\n        // prev     next\n        this.updateCursors(item, item.prev, item, item.next);\n\n        if (item.prev !== null) {\n            item.prev.next = item.next;\n        } else {\n            if (this.head !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.head = item.next;\n        }\n\n        if (item.next !== null) {\n            item.next.prev = item.prev;\n        } else {\n            if (this.tail !== item) {\n                throw new Error('item doesn\\'t belong to list');\n            }\n\n            this.tail = item.prev;\n        }\n\n        item.prev = null;\n        item.next = null;\n\n        return item;\n    }\n    push(data) {\n        this.insert(List.createItem(data));\n    }\n    pop() {\n        return this.tail !== null ? this.remove(this.tail) : null;\n    }\n    unshift(data) {\n        this.prepend(List.createItem(data));\n    }\n    shift() {\n        return this.head !== null ? this.remove(this.head) : null;\n    }\n    prependList(list) {\n        return this.insertList(list, this.head);\n    }\n    appendList(list) {\n        return this.insertList(list);\n    }\n    insertList(list, before) {\n        // ignore empty lists\n        if (list.head === null) {\n            return this;\n        }\n\n        if (before !== undefined && before !== null) {\n            this.updateCursors(before.prev, list.tail, before, list.head);\n\n            // insert in the middle of dist list\n            if (before.prev !== null) {\n                // before.prev <-> list.head\n                before.prev.next = list.head;\n                list.head.prev = before.prev;\n            } else {\n                this.head = list.head;\n            }\n\n            before.prev = list.tail;\n            list.tail.next = before;\n        } else {\n            this.updateCursors(this.tail, list.tail, null, list.head);\n\n            // insert to end of the list\n            if (this.tail !== null) {\n                // if destination list has a tail, then it also has a head,\n                // but head doesn't change\n                // dest tail -> source head\n                this.tail.next = list.head;\n                // dest tail <- source head\n                list.head.prev = this.tail;\n            } else {\n                // if list has no a tail, then it also has no a head\n                // in this case points head to new item\n                this.head = list.head;\n            }\n\n            // tail always start point to new item\n            this.tail = list.tail;\n        }\n\n        list.head = null;\n        list.tail = null;\n        return this;\n    }\n    replace(oldItem, newItemOrList) {\n        if ('head' in newItemOrList) {\n            this.insertList(newItemOrList, oldItem);\n        } else {\n            this.insert(newItemOrList, oldItem);\n        }\n\n        this.remove(oldItem);\n    }\n}\n", "export function createCustomError(name, message) {\n    // use Object.create(), because some VMs prevent setting line/column otherwise\n    // (iOS Safari 10 even throws an exception)\n    const error = Object.create(SyntaxError.prototype);\n    const errorStack = new Error();\n\n    return Object.assign(error, {\n        name,\n        message,\n        get stack() {\n            return (errorStack.stack || '').replace(/^(.+\\n){1,3}/, `${name}: ${message}\\n`);\n        }\n    });\n};\n", "import { createCustomError } from '../utils/create-custom-error.js';\n\nconst MAX_LINE_LENGTH = 100;\nconst OFFSET_CORRECTION = 60;\nconst TAB_REPLACEMENT = '    ';\n\nfunction sourceFragment({ source, line, column, baseLine, baseColumn }, extraLines) {\n    function processLines(start, end) {\n        return lines\n            .slice(start, end)\n            .map((line, idx) =>\n                String(start + idx + 1).padStart(maxNumLength) + ' |' + line\n            ).join('\\n');\n    }\n\n    const prelines = '\\n'.repeat(Math.max(baseLine - 1, 0));\n    const precolumns = ' '.repeat(Math.max(baseColumn - 1, 0));\n    const lines = (prelines + precolumns + source).split(/\\r\\n?|\\n|\\f/);\n    const startLine = Math.max(1, line - extraLines) - 1;\n    const endLine = Math.min(line + extraLines, lines.length + 1);\n    const maxNumLength = Math.max(4, String(endLine).length) + 1;\n    let cutLeft = 0;\n\n    // column correction according to replaced tab before column\n    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\\t/g) || []).length;\n\n    if (column > MAX_LINE_LENGTH) {\n        cutLeft = column - OFFSET_CORRECTION + 3;\n        column = OFFSET_CORRECTION - 2;\n    }\n\n    for (let i = startLine; i <= endLine; i++) {\n        if (i >= 0 && i < lines.length) {\n            lines[i] = lines[i].replace(/\\t/g, TAB_REPLACEMENT);\n            lines[i] =\n                (cutLeft > 0 && lines[i].length > cutLeft ? '\\u2026' : '') +\n                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +\n                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\\u2026' : '');\n        }\n    }\n\n    return [\n        processLines(startLine, line),\n        new Array(column + maxNumLength + 2).join('-') + '^',\n        processLines(line, endLine)\n    ].filter(Boolean)\n        .join('\\n')\n        .replace(/^(\\s+\\d+\\s+\\|\\n)+/, '')\n        .replace(/\\n(\\s+\\d+\\s+\\|)+$/, '');\n}\n\nexport function SyntaxError(message, source, offset, line, column, baseLine = 1, baseColumn = 1) {\n    const error = Object.assign(createCustomError('SyntaxError', message), {\n        source,\n        offset,\n        line,\n        column,\n        sourceFragment(extraLines) {\n            return sourceFragment({ source, line, column, baseLine, baseColumn }, isNaN(extraLines) ? 0 : extraLines);\n        },\n        get formattedMessage() {\n            return (\n                `Parse error: ${message}\\n` +\n                sourceFragment({ source, line, column, baseLine, baseColumn }, 2)\n            );\n        }\n    });\n\n    return error;\n}\n", "import { WhiteSpace, Comment } from '../tokenizer/index.js';\n\nexport function readSequence(recognizer) {\n    const children = this.createList();\n    let space = false;\n    const context = {\n        recognizer\n    };\n\n    while (!this.eof) {\n        switch (this.tokenType) {\n            case Comment:\n                this.next();\n                continue;\n\n            case WhiteSpace:\n                space = true;\n                this.next();\n                continue;\n        }\n\n        let child = recognizer.getNode.call(this, context);\n\n        if (child === undefined) {\n            break;\n        }\n\n        if (space) {\n            if (recognizer.onWhiteSpace) {\n                recognizer.onWhiteSpace.call(this, child, children, context);\n            }\n            space = false;\n        }\n\n        children.push(child);\n    }\n\n    if (space && recognizer.onWhiteSpace) {\n        recognizer.onWhiteSpace.call(this, null, children, context);\n    }\n\n    return children;\n};\n", "import { List } from '../utils/List.js';\nimport { SyntaxError } from './SyntaxError.js';\nimport {\n    tokenize,\n    OffsetToLocation,\n    TokenStream,\n    tokenNames,\n\n    consumeNumber,\n    findWhiteSpaceStart,\n    cmpChar,\n    cmpStr,\n\n    WhiteSpace,\n    Comment,\n    Ident,\n    Function as FunctionToken,\n    Url,\n    Hash,\n    Percentage,\n    Number as NumberToken\n} from '../tokenizer/index.js';\nimport { readSequence } from './sequence.js';\n\nconst NOOP = () => {};\nconst EXCLAMATIONMARK = 0x0021;  // U+0021 EXCLAMATION MARK (!)\nconst NUMBERSIGN = 0x0023;       // U+0023 NUMBER SIGN (#)\nconst SEMICOLON = 0x003B;        // U+003B SEMICOLON (;)\nconst LEFTCURLYBRACKET = 0x007B; // U+007B LEFT CURLY BRACKET ({)\nconst NULL = 0;\n\nfunction createParseContext(name) {\n    return function() {\n        return this[name]();\n    };\n}\n\nfunction fetchParseValues(dict) {\n    const result = Object.create(null);\n\n    for (const name of Object.keys(dict)) {\n        const item = dict[name];\n        const fn = item.parse || item;\n\n        if (fn) {\n            result[name] = fn;\n        }\n    }\n\n    return result;\n}\n\nfunction processConfig(config) {\n    const parseConfig = {\n        context: Object.create(null),\n        features: Object.assign(Object.create(null), config.features),\n        scope: Object.assign(Object.create(null), config.scope),\n        atrule: fetchParseValues(config.atrule),\n        pseudo: fetchParseValues(config.pseudo),\n        node: fetchParseValues(config.node)\n    };\n\n    for (const [name, context] of Object.entries(config.parseContext)) {\n        switch (typeof context) {\n            case 'function':\n                parseConfig.context[name] = context;\n                break;\n\n            case 'string':\n                parseConfig.context[name] = createParseContext(context);\n                break;\n        }\n    }\n\n    return {\n        config: parseConfig,\n        ...parseConfig,\n        ...parseConfig.node\n    };\n}\n\nexport function createParser(config) {\n    let source = '';\n    let filename = '<unknown>';\n    let needPositions = false;\n    let onParseError = NOOP;\n    let onParseErrorThrow = false;\n\n    const locationMap = new OffsetToLocation();\n    const parser = Object.assign(new TokenStream(), processConfig(config || {}), {\n        parseAtrulePrelude: true,\n        parseRulePrelude: true,\n        parseValue: true,\n        parseCustomProperty: false,\n\n        readSequence,\n\n        consumeUntilBalanceEnd: () => 0,\n        consumeUntilLeftCurlyBracket(code) {\n            return code === LEFTCURLYBRACKET ? 1 : 0;\n        },\n        consumeUntilLeftCurlyBracketOrSemicolon(code) {\n            return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;\n        },\n        consumeUntilExclamationMarkOrSemicolon(code) {\n            return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;\n        },\n        consumeUntilSemicolonIncluded(code) {\n            return code === SEMICOLON ? 2 : 0;\n        },\n\n        createList() {\n            return new List();\n        },\n        createSingleNodeList(node) {\n            return new List().appendData(node);\n        },\n        getFirstListNode(list) {\n            return list && list.first;\n        },\n        getLastListNode(list) {\n            return list && list.last;\n        },\n\n        parseWithFallback(consumer, fallback) {\n            const startIndex = this.tokenIndex;\n\n            try {\n                return consumer.call(this);\n            } catch (e) {\n                if (onParseErrorThrow) {\n                    throw e;\n                }\n\n                this.skip(startIndex - this.tokenIndex);\n                const fallbackNode = fallback.call(this);\n\n                onParseErrorThrow = true;\n                onParseError(e, fallbackNode);\n                onParseErrorThrow = false;\n\n                return fallbackNode;\n            }\n        },\n\n        lookupNonWSType(offset) {\n            let type;\n\n            do {\n                type = this.lookupType(offset++);\n                if (type !== WhiteSpace && type !== Comment) {\n                    return type;\n                }\n            } while (type !== NULL);\n\n            return NULL;\n        },\n\n        charCodeAt(offset) {\n            return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;\n        },\n        substring(offsetStart, offsetEnd) {\n            return source.substring(offsetStart, offsetEnd);\n        },\n        substrToCursor(start) {\n            return this.source.substring(start, this.tokenStart);\n        },\n\n        cmpChar(offset, charCode) {\n            return cmpChar(source, offset, charCode);\n        },\n        cmpStr(offsetStart, offsetEnd, str) {\n            return cmpStr(source, offsetStart, offsetEnd, str);\n        },\n\n        consume(tokenType) {\n            const start = this.tokenStart;\n\n            this.eat(tokenType);\n\n            return this.substrToCursor(start);\n        },\n        consumeFunctionName() {\n            const name = source.substring(this.tokenStart, this.tokenEnd - 1);\n\n            this.eat(FunctionToken);\n\n            return name;\n        },\n        consumeNumber(type) {\n            const number = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));\n\n            this.eat(type);\n\n            return number;\n        },\n\n        eat(tokenType) {\n            if (this.tokenType !== tokenType) {\n                const tokenName = tokenNames[tokenType].slice(0, -6).replace(/-/g, ' ').replace(/^./, m => m.toUpperCase());\n                let message = `${/[[\\](){}]/.test(tokenName) ? `\"${tokenName}\"` : tokenName} is expected`;\n                let offset = this.tokenStart;\n\n                // tweak message and offset\n                switch (tokenType) {\n                    case Ident:\n                        // when identifier is expected but there is a function or url\n                        if (this.tokenType === FunctionToken || this.tokenType === Url) {\n                            offset = this.tokenEnd - 1;\n                            message = 'Identifier is expected but function found';\n                        } else {\n                            message = 'Identifier is expected';\n                        }\n                        break;\n\n                    case Hash:\n                        if (this.isDelim(NUMBERSIGN)) {\n                            this.next();\n                            offset++;\n                            message = 'Name is expected';\n                        }\n                        break;\n\n                    case Percentage:\n                        if (this.tokenType === NumberToken) {\n                            offset = this.tokenEnd;\n                            message = 'Percent sign is expected';\n                        }\n                        break;\n                }\n\n                this.error(message, offset);\n            }\n\n            this.next();\n        },\n        eatIdent(name) {\n            if (this.tokenType !== Ident || this.lookupValue(0, name) === false) {\n                this.error(`Identifier \"${name}\" is expected`);\n            }\n\n            this.next();\n        },\n        eatDelim(code) {\n            if (!this.isDelim(code)) {\n                this.error(`Delim \"${String.fromCharCode(code)}\" is expected`);\n            }\n\n            this.next();\n        },\n\n        getLocation(start, end) {\n            if (needPositions) {\n                return locationMap.getLocationRange(\n                    start,\n                    end,\n                    filename\n                );\n            }\n\n            return null;\n        },\n        getLocationFromList(list) {\n            if (needPositions) {\n                const head = this.getFirstListNode(list);\n                const tail = this.getLastListNode(list);\n                return locationMap.getLocationRange(\n                    head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,\n                    tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,\n                    filename\n                );\n            }\n\n            return null;\n        },\n\n        error(message, offset) {\n            const location = typeof offset !== 'undefined' && offset < source.length\n                ? locationMap.getLocation(offset)\n                : this.eof\n                    ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1))\n                    : locationMap.getLocation(this.tokenStart);\n\n            throw new SyntaxError(\n                message || 'Unexpected input',\n                source,\n                location.offset,\n                location.line,\n                location.column,\n                locationMap.startLine,\n                locationMap.startColumn\n            );\n        }\n    });\n\n    const parse = function(source_, options) {\n        source = source_;\n        options = options || {};\n\n        parser.setSource(source, tokenize);\n        locationMap.setSource(\n            source,\n            options.offset,\n            options.line,\n            options.column\n        );\n\n        filename = options.filename || '<unknown>';\n        needPositions = Boolean(options.positions);\n        onParseError = typeof options.onParseError === 'function' ? options.onParseError : NOOP;\n        onParseErrorThrow = false;\n\n        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n        const { context = 'default', onComment } = options;\n\n        if (context in parser.context === false) {\n            throw new Error('Unknown context `' + context + '`');\n        }\n\n        if (typeof onComment === 'function') {\n            parser.forEachToken((type, start, end) => {\n                if (type === Comment) {\n                    const loc = parser.getLocation(start, end);\n                    const value = cmpStr(source, end - 2, end, '*/')\n                        ? source.slice(start + 2, end - 2)\n                        : source.slice(start + 2, end);\n\n                    onComment(value, loc);\n                }\n            });\n        }\n\n        const ast = parser.context[context].call(parser, options);\n\n        if (!parser.eof) {\n            parser.error();\n        }\n\n        return ast;\n    };\n\n    return Object.assign(parse, {\n        SyntaxError,\n        config: parser.config\n    });\n};\n", "import {\n    Delim,\n    Ident,\n    Dimension,\n    Percentage,\n    Number as NumberToken,\n    Hash,\n    Colon,\n    LeftSquareBracket\n} from '../../tokenizer/index.js';\n\nconst NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nconst AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)\nconst ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nconst PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nconst SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nconst FULLSTOP = 0x002E;        // U+002E FULL STOP (.)\nconst GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nconst VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)\nconst TILDE = 0x007E;           // U+007E TILDE (~)\n\nfunction onWhiteSpace(next, children) {\n    if (children.last !== null && children.last.type !== 'Combinator' &&\n        next !== null && next.type !== 'Combinator') {\n        children.push({  // FIXME: this.Combinator() should be used instead\n            type: 'Combinator',\n            loc: null,\n            name: ' '\n        });\n    }\n}\n\nfunction getNode() {\n    switch (this.tokenType) {\n        case LeftSquareBracket:\n            return this.AttributeSelector();\n\n        case Hash:\n            return this.IdSelector();\n\n        case Colon:\n            if (this.lookupType(1) === Colon) {\n                return this.PseudoElementSelector();\n            } else {\n                return this.PseudoClassSelector();\n            }\n\n        case Ident:\n            return this.TypeSelector();\n\n        case NumberToken:\n        case Percentage:\n            return this.Percentage();\n\n        case Dimension:\n            // throws when .123ident\n            if (this.charCodeAt(this.tokenStart) === FULLSTOP) {\n                this.error('Identifier is expected', this.tokenStart + 1);\n            }\n            break;\n\n        case Delim: {\n            const code = this.charCodeAt(this.tokenStart);\n\n            switch (code) {\n                case PLUSSIGN:\n                case GREATERTHANSIGN:\n                case TILDE:\n                case SOLIDUS:  // /deep/\n                    return this.Combinator();\n\n                case FULLSTOP:\n                    return this.ClassSelector();\n\n                case ASTERISK:\n                case VERTICALLINE:\n                    return this.TypeSelector();\n\n                case NUMBERSIGN:\n                    return this.IdSelector();\n\n                case AMPERSAND:\n                    return this.NestingSelector();\n            }\n\n            break;\n        }\n    }\n};\n\nexport default {\n    onWhiteSpace,\n    getNode\n};\n", "import { Comma, String as StringToken, Ident, RightParenthesis } from '../../tokenizer/index.js';\n\nexport function parseLanguageRangeList() {\n    const children = this.createList();\n\n    this.skipSC();\n\n    loop: while (!this.eof) {\n        switch (this.tokenType) {\n            case Ident:\n                children.push(this.Identifier());\n                break;\n\n            case StringToken:\n                children.push(this.String());\n                break;\n\n            case Comma:\n                children.push(this.Operator());\n                break;\n\n            case RightParenthesis:\n                break loop;\n\n            default:\n                this.error('Identifier, string or comma is expected');\n        }\n\n        this.skipSC();\n    }\n\n    return children;\n}\n", "import { parseLanguageRangeList } from './lang.js';\n\nconst selectorList = {\n    parse() {\n        return this.createSingleNodeList(\n            this.SelectorList()\n        );\n    }\n};\n\nconst selector = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Selector()\n        );\n    }\n};\n\nconst identList = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Identifier()\n        );\n    }\n};\n\nconst langList = {\n    parse: parseLanguageRangeList\n};\n\nconst nth = {\n    parse() {\n        return this.createSingleNodeList(\n            this.Nth()\n        );\n    }\n};\n\nexport default {\n    'dir': identList,\n    'has': selectorList,\n    'lang': langList,\n    'matches': selectorList,\n    'is': selectorList,\n    '-moz-any': selectorList,\n    '-webkit-any': selectorList,\n    'where': selectorList,\n    'not': selectorList,\n    'nth-child': nth,\n    'nth-last-child': nth,\n    'nth-last-of-type': nth,\n    'nth-of-type': nth,\n    'slotted': selector,\n    'host': selector,\n    'host-context': selector\n};\n", "export { parse as AnPlusB } from './AnPlusB.js';\nexport { parse as AttributeSelector } from './AttributeSelector.js';\nexport { parse as ClassSelector } from './ClassSelector.js';\nexport { parse as Combinator } from './Combinator.js';\nexport { parse as Identifier } from './Identifier.js';\nexport { parse as IdSelector } from './IdSelector.js';\nexport { parse as NestingSelector } from './NestingSelector.js';\nexport { parse as Nth } from './Nth.js';\nexport { parse as Operator } from './Operator.js';\nexport { parse as Percentage } from './Percentage.js';\nexport { parse as PseudoClassSelector } from './PseudoClassSelector.js';\nexport { parse as PseudoElementSelector } from './PseudoElementSelector.js';\nexport { parse as Raw } from './Raw.js';\nexport { parse as Selector } from './Selector.js';\nexport { parse as SelectorList } from './SelectorList.js';\nexport { parse as String } from './String.js';\nexport { parse as TypeSelector } from './TypeSelector.js';\n", "import { Selector } from '../scope/index.js';\nimport pseudo from '../pseudo/index.js';\nimport * as node from '../node/index-parse-selector.js';\n\nexport default {\n    parseContext: {\n        default: 'SelectorList',\n        selectorList: 'SelectorList',\n        selector: 'Selector'\n    },\n    scope: { Selector },\n    atrule: {},\n    pseudo,\n    node\n};\n", "import { createParser } from './create.js';\nimport config from '../syntax/config/parser-selector.js';\n\nexport default createParser(config);\n", "const compare = (s1, s2) => {\n    if (s1.a === s2.a) {\n        if (s1.b === s2.b) {\n            return s1.c - s2.c;\n        }\n        return s1.b - s2.b;\n    }\n    return s1.a - s2.a;\n};\n\nconst equals = (s1, s2) => {\n    return compare(s1, s2) === 0;\n};\n\nconst greaterThan = (s1, s2) => {\n    return compare(s1, s2) > 0;\n};\n\nconst lessThan = (s1, s2) => {\n    return compare(s1, s2) < 0;\n};\n\nexport { compare, equals, greaterThan, lessThan };\n", "import { compare } from './compare.js';\n\nconst sort = (specificities, order = 'ASC') => {\n    const sorted = specificities.sort(compare);\n\n    if (order === 'DESC') {\n        return sorted.reverse();\n    }\n\n    return sorted;\n};\n\nconst sortAsc = (...specificities) => {\n    return sort(specificities, 'ASC');\n};\n\nconst sortDesc = (...specificities) => {\n    return sort(specificities, 'DESC');\n};\n\nexport { sortAsc, sortDesc };\n", "import { sortAsc, sortDesc } from './sort.js';\n\nconst max = (...specificities) => {\n    const sorted = sortDesc(...specificities);\n    return sorted[0];\n};\n\nconst min = (...specificities) => {\n    const sorted = sortAsc(...specificities);\n    return sorted[0];\n};\n\nexport { max, min };\n", "import parse from 'css-tree/selector-parser';\nimport Specificity from '../index.js';\nimport { max } from './../util/index.js';\n\n/** @param {import('css-tree').Selector} selectorAST */\nconst calculateForAST = (selectorAST) => {\n    // Quit while you're ahead\n    if (!selectorAST || selectorAST.type !== 'Selector') {\n        throw new TypeError(`Passed in source is not a Selector AST`);\n    }\n\n    // https://www.w3.org/TR/selectors-4/#specificity-rules\n    let a = 0; /* ID Selectors */\n    let b = 0; /* Class selectors, Attributes selectors, and Pseudo-classes */\n    let c = 0; /* Type selectors and Pseudo-elements */\n\n    selectorAST.children.forEach((child) => {\n        switch (child.type) {\n            case 'IdSelector':\n                a += 1;\n                break;\n\n            case 'AttributeSelector':\n            case 'ClassSelector':\n                b += 1;\n                break;\n\n            case 'PseudoClassSelector':\n                switch (child.name.toLowerCase()) {\n                    // \u201CThe specificity of a :where() pseudo-class is replaced by zero.\u201D\n                    case 'where':\n                        // Noop :)\n                        break;\n\n                    case '-webkit-any':\n                    case 'any':\n                        if (child.children?.first) {\n                            b += 1;\n                        }\n                        break;\n\n                    // \u201CThe specificity of an :is(), :not(), or :has() pseudo-class is replaced by the specificity of the most specific complex selector in its selector list argument.\u201C\n                    case '-moz-any':\n                    case 'is':\n                    case 'matches':\n                    case 'not':\n                    case 'has':\n                        if (child.children?.first) {\n                            // Calculate Specificity from nested SelectorList\n                            const max1 = max(...calculate(child.children.first));\n\n                            // Adjust orig specificity\n                            a += max1.a;\n                            b += max1.b;\n                            c += max1.c;\n                        }\n\n                        break;\n\n                    // \u201CThe specificity of an :nth-child() or :nth-last-child() selector is the specificity of the pseudo class itself (counting as one pseudo-class selector) plus the specificity of the most specific complex selector in its selector list argument\u201D\n                    case 'nth-child':\n                    case 'nth-last-child':\n                        b += 1;\n\n                        if (child.children?.first?.selector) {\n                            // Calculate Specificity from SelectorList\n                            const max2 = max(...calculate(child.children.first.selector));\n\n                            // Adjust orig specificity\n                            a += max2.a;\n                            b += max2.b;\n                            c += max2.c;\n                        }\n                        break;\n\n                    // \u201CThe specificity of :host is that of a pseudo-class. The specificity of :host() is that of a pseudo-class, plus the specificity of its argument.\u201D\n                    // \u201CThe specificity of :host-context() is that of a pseudo-class, plus the specificity of its argument.\u201D\n                    case 'host-context':\n                    case 'host':\n                        b += 1;\n\n                        if (child.children?.first?.children) {\n                            // Workaround to a css-tree bug in which it allows complex selectors instead of only compound selectors\n                            // We work around it by filtering out any Combinator and successive Selectors\n                            const childAST = { type: 'Selector', children: [] };\n                            let foundCombinator = false;\n                            child.children.first.children.forEach((entry) => {\n                                if (foundCombinator) return false;\n                                if (entry.type === 'Combinator') {\n                                    foundCombinator = true;\n                                    return false;\n                                }\n                                childAST.children.push(entry);\n                            });\n\n                            // Calculate Specificity from Selector\n                            const childSpecificity = calculate(childAST)[0];\n\n                            // Adjust orig specificity\n                            a += childSpecificity.a;\n                            b += childSpecificity.b;\n                            c += childSpecificity.c;\n                        }\n                        break;\n\n                    // Improper use of Pseudo-Class Selectors instead of a Pseudo-Element\n                    // @ref https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements#index\n                    case 'after':\n                    case 'before':\n                    case 'first-letter':\n                    case 'first-line':\n                        c += 1;\n                        break;\n\n                    default:\n                        b += 1;\n                        break;\n                }\n                break;\n\n            case 'PseudoElementSelector':\n                switch (child.name) {\n                    // \u201CThe specificity of ::slotted() is that of a pseudo-element, plus the specificity of its argument.\u201D\n                    case 'slotted':\n                        c += 1;\n\n                        if (child.children?.first?.children) {\n                            // Workaround to a css-tree bug in which it allows complex selectors instead of only compound selectors\n                            // We work around it by filtering out any Combinator and successive Selectors\n                            const childAST = { type: 'Selector', children: [] };\n                            let foundCombinator = false;\n                            child.children.first.children.forEach((entry) => {\n                                if (foundCombinator) return false;\n                                if (entry.type === 'Combinator') {\n                                    foundCombinator = true;\n                                    return false;\n                                }\n                                childAST.children.push(entry);\n                            });\n\n                            // Calculate Specificity from Selector\n                            const childSpecificity = calculate(childAST)[0];\n\n                            // Adjust orig specificity\n                            a += childSpecificity.a;\n                            b += childSpecificity.b;\n                            c += childSpecificity.c;\n                        }\n                        break;\n\n                    case 'view-transition-group':\n                    case 'view-transition-image-pair':\n                    case 'view-transition-old':\n                    case 'view-transition-new':\n                        // The specificity of a view-transition selector with a * argument is zero.\n                        if (child.children?.first?.value === '*') {\n                            break;\n                        }\n                        // The specificity of a view-transition selector with an argument is the same\n                        // as for other pseudo - elements, and is equivalent to a type selector.\n                        c += 1;\n                        break;\n\n                    default:\n                        c += 1;\n                        break;\n                }\n                break;\n\n            case 'TypeSelector':\n                // Omit namespace\n                let typeSelector = child.name;\n                if (typeSelector.includes('|')) {\n                    typeSelector = typeSelector.split('|')[1];\n                }\n\n                // \u201CIgnore the universal selector\u201D\n                if (typeSelector !== '*') {\n                    c += 1;\n                }\n                break;\n\n            default:\n                // NOOP\n                break;\n        }\n    });\n\n    return new Specificity({ a, b, c }, selectorAST);\n};\n\nconst convertToAST = (source) => {\n    // The passed in argument was a String.\n    // ~> Let's try and parse to an AST\n    if (typeof source === 'string' || source instanceof String) {\n        try {\n            return parse(source, {\n                context: 'selectorList',\n            });\n        } catch (e) {\n            throw new TypeError(`Could not convert passed in source '${source}' to SelectorList: ${e.message}`);\n        }\n    }\n\n    // The passed in argument was an Object.\n    // ~> Let's verify if it's a AST of the type Selector or SelectorList\n    if (source instanceof Object) {\n        if (source.type && ['Selector', 'SelectorList'].includes(source.type)) {\n            return source;\n        }\n\n        // Manually parsing subtree when the child is of the type Raw, most likely due to https://github.com/csstree/csstree/issues/151\n        if (source.type && source.type === 'Raw') {\n            try {\n                return parse(source.value, {\n                    context: 'selectorList',\n                });\n            } catch (e) {\n                throw new TypeError(`Could not convert passed in source to SelectorList: ${e.message}`);\n            }\n        }\n\n        throw new TypeError(`Passed in source is an Object but no AST / AST of the type Selector or SelectorList`);\n    }\n\n    throw new TypeError(`Passed in source is not a String nor an Object. I don't know what to do with it.`);\n};\n\n/**\n * @param {string} selector\n * @returns {Specificity[]}\n */\nconst calculate = (selector) => {\n    // Quit while you're ahead\n    if (!selector) {\n        return [];\n    }\n\n    // Make sure we have a SelectorList AST\n    // If not, an exception will be thrown\n    const ast = convertToAST(selector);\n\n    // Selector?\n    if (ast.type === 'Selector') {\n        return [calculateForAST(selector)];\n    }\n\n    // SelectorList?\n    // ~> Calculate Specificity for each contained Selector\n    if (ast.type === 'SelectorList') {\n        const specificities = [];\n        ast.children.forEach((childAST) => {\n            const specificity = calculateForAST(childAST);\n            specificities.push(specificity);\n        });\n        return specificities;\n    }\n};\n\nexport { calculate, calculateForAST };\n"],
  "mappings": "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",
  "names": []
}
